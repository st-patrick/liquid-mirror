<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Liquid Mirror — Hemi Env Buttons (stable)</title>
  <style>
    :root { --bg:#0e0f12; --card:#16181d; --fg:#e6e9ef; --muted:#9aa3b2; }
    html, body { height:100%; }
    body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:radial-gradient(80% 100% at 50% 0%, #13151a, #0b0c0f 70%); color:var(--fg); display:grid; place-items:center; padding:32px; }
    .wrap { display:grid; gap:24px; grid-template-columns: minmax(260px, 420px) 1fr; width:min(1200px, 94vw); align-items:start; }
    .card { background:var(--card); border:1px solid #23262d; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25) inset, 0 10px 40px rgba(0,0,0,.4); }
    .controls { display:grid; gap:12px; }
    .row { display:grid; gap:10px; }
    .row.cols-2 { grid-template-columns: 1fr 1fr; }
    label { display:grid; gap:6px; font-weight:600; }
    input[type="range"] { width:100%; }
    .btn { display:inline-flex; align-items:center; gap:10px; padding:10px 12px; border-radius: 10px; border:1px solid #272a31; background:#15171b; color:#e6ebf3; cursor:pointer; }
    .btn:hover { background:#1a1d22; }
    code{ background:#0f1114; border:1px solid #252831; padding:2px 6px; border-radius:6px; }

    .env-button { position:relative; overflow:hidden; border-radius:18px; display:grid; place-items:center; padding:18px 22px; background:#0b0c0f; isolation:isolate; }
    .env-button > canvas, .env-button > .overlay { position:absolute; inset:0; width:100%; height:100%; display:block; pointer-events:none; }
    .env-button > .overlay { z-index: 2; }
    .env-button > .content { position:relative; z-index:3; display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.2px; }
    .env-button .sub { font-size:12px; color:#9aa3b2; font-weight:600; }

    .grid { display:grid; grid-template-columns:repeat(2, minmax(240px, 1fr)); gap:16px; }
    .chip { background: #111317; padding:6px 10px; border-radius:10px; border:1px solid #2a2f37; color:#aeb6c6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2 style="margin:4px 0 8px;">Liquid Mirror — Hemi Env Buttons</h2>
      <p class="muted">Webcam as a live front-hemisphere environment map for glossy "liquid glass" UI elements. Includes angle zones (0, ±30, ±45, ±60) overlay and FOV calibration.</p>
      <div class="controls">
        <div class="row cols-2">
          <label>Horizontal FOV (deg)
            <input id="hfov" type="range" min="40" max="110" step="1" value="75">
            <div class="chip" id="hfovVal">75 deg</div>
          </label>
          <label>Liquid ripple
            <input id="ripple" type="range" min="0" max="1" step="0.01" value="0.25">
            <div class="chip" id="rippleVal">0.25</div>
          </label>
        </div>
        <div class="row cols-2">
          <button class="btn" id="toggleOverlay">Toggle zones overlay</button>
          <button class="btn" id="flip">Flip webcam (mirror)</button>
        </div>
        <p class="muted">API: <code>EnvButtons.applyTo('.env-button', { hfovDeg:75, ripple:0.25, flip:true })</code></p>
      </div>
    </div>

    <div class="grid">
      <div class="env-button" id="btn1">
        <div class="content">Liquid Glass Button</div>
        <div class="sub content">live reflection from your room</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
      <div class="env-button" id="btn2" style="border-radius: 999px; aspect-ratio: 1;">
        <div class="content">Round Glass</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
    </div>
  </div>

  <script>
  (function(){
    "use strict";
    if (!window.EnvMirror) window.EnvMirror = {};

    /* Camera (guarded) */
    if (!window.EnvMirror.Camera) {
      var CS = { stream:null, video:null, ready:false };
      async function ensureCamera(){
        if (CS.ready && CS.video && !CS.video.paused) return CS;
        var constraints = { video: { facingMode:"user" }, audio:false };
        var stream = await navigator.mediaDevices.getUserMedia(constraints);
        var v = document.createElement("video");
        v.autoplay = true; v.playsInline = true; v.muted = true; v.srcObject = stream; await v.play();
        CS.stream = stream; CS.video = v; CS.ready = true; return CS;
      }
      window.EnvMirror.Camera = { ensure: ensureCamera, state: CS };
    }
    var Camera = window.EnvMirror.Camera;

    /* WebGL factory (guarded) */
    if (!window.EnvMirror.makeGL) {
      window.EnvMirror.makeGL = function(canvas){
        var gl = canvas.getContext("webgl", { alpha:true, antialias:true, premultipliedAlpha:true });
        if(!gl) throw new Error("WebGL not available");
        function compile(type, src){
          var s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
            var info = gl.getShaderInfoLog(s) || "unknown compile error";
            console.error("Shader compile error:", info, "\nSource:\n", src);
            throw new Error(info);
          }
          return s;
        }
        var vsSrc = [
          "attribute vec2 aPos;",
          "varying vec2 vUv;",
          "void main(){ vUv = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.,1.); }"
        ].join("\n");

        // IMPORTANT: build FS via Array.join to avoid concatenation mistakes
        var fsSrc = [
          "precision mediump float;",
          "varying vec2 vUv;",
          "uniform sampler2D uCam; uniform vec2 uCamSize; uniform vec2 uRes;",
          "uniform float uTime; uniform float uHFov; uniform float uVFov; uniform float uFlip;",
          "uniform float uRipple; uniform float uRound;",
          "float hash(vec2 p){ return fract(sin(dot(p, vec2(41.3,289.1)))*43758.5453); }",
          "float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1.,0.)), c=hash(i+vec2(0.,1.)), d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }",
          "float fbm(vec2 p){ float s=0., a=0.5; for(int i=0;i<4;i++){ s+=a*noise(p); p*=2.07; a*=0.5; } return s; }",
          "vec3 domeNormal(vec2 uv){",
          "  float aspect = uRes.x / max(uRes.y, 1.0);",
          "  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);",
          "  float r2 = dot(p,p);",
          "  float R = 0.5; float rr = min(sqrt(r2)/R, 0.999);",
          "  float z = sqrt(1.0 - rr*rr);",
          "  vec3 N = normalize(vec3(p.x/(R*R*z + 1e-5), p.y/(R*R*z + 1e-5), 1.0));",
          "  N = mix(normalize(vec3(0.6*p.x, 0.6*p.y, 1.0)), N, uRound);",
          "  return N;",
          "}",
          "vec2 sampleFromWebcam(vec3 R){",
          "  float phi = atan(R.x, R.z);",
          "  float theta = asin(clamp(R.y, -1.0, 1.0));",
          "  float u = 0.5 + phi / uHFov;",
          "  float v = 0.5 - theta / uVFov;",
          "  if (uFlip > 0.5) u = 1.0 - u;",
          "  return clamp(vec2(u, v), 0.0, 1.0);",
          "}",
          "void main(){",
          "  vec3 V = vec3(0.0, 0.0, 1.0);",
          "  vec3 N = domeNormal(vUv);",
          "  if (uRipple > 0.001){",
          "    float r = uRipple * 0.6; vec2 q = vUv * uRes.xy * 0.005 + vec2(0.0, uTime*0.2); float rip = fbm(q);",
          "    N.xy += (rip - 0.5) * r; N = normalize(N);",
          "  }",
          "  vec3 R = reflect(-V, N); R.z = max(R.z, 1e-3);",
          "  vec2 camUV = sampleFromWebcam(normalize(R));",
          "  vec3 env = texture2D(uCam, camUV).rgb;",
          "  float NdV = clamp(dot(N, V), 0.0, 1.0);",
          "  float F0 = 0.06; float F = F0 + (1.0 - F0) * pow(1.0 - NdV, 5.0);",
          "  vec3 tint = vec3(0.95, 0.98, 1.0);",
          "  vec3 col = mix(tint * 0.08, env, F);",
          "  float sheen = pow(1.0 - length((vUv - 0.5) * 2.0), 20.0) * 0.35; col += sheen;",
          "  gl_FragColor = vec4(col, 1.0);",
          "}"
        ].join("\n");

        var vs = compile(gl.VERTEX_SHADER, vsSrc);
        var fs = compile(gl.FRAGMENT_SHADER, fsSrc);
        var prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
        if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
        gl.useProgram(prog);
        var quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
        var aPos = gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
        var tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        function U(n){ return gl.getUniformLocation(prog, n); }
        var uniforms = { uCam:U('uCam'), uCamSize:U('uCamSize'), uRes:U('uRes'), uTime:U('uTime'), uHFov:U('uHFov'), uVFov:U('uVFov'), uFlip:U('uFlip'), uRipple:U('uRipple'), uRound:U('uRound') };
        return { gl:gl, prog:prog, tex:tex, uniforms:uniforms };
      };
    }
    var makeGL = window.EnvMirror.makeGL;

    /* EnvButtons (guarded) */
    if (!window.EnvButtons) {
      window.EnvButtons = (function(){
        var instances = new Map();
        function hfovToVfov(hfov, aspect){ return 2*Math.atan(Math.tan(hfov/2)/aspect); }
        function create(host, opts){
          var options = Object.assign({ hfovDeg:75, ripple:0.25, flip:true, roundHint:0.6, showOverlay:true }, opts||{});
          var canvas = host.querySelector('canvas'); var overlay = host.querySelector('.overlay');
          var glx = makeGL(canvas); var gl = glx.gl;
          var dpr = Math.max(1, window.devicePixelRatio||1);
          function resize(){ var r = host.getBoundingClientRect(); var W = Math.max(1,(r.width*dpr)|0), H = Math.max(1,(r.height*dpr)|0); if(canvas.width!==W||canvas.height!==H){ canvas.width=W; canvas.height=H; gl.viewport(0,0,W,H); drawOverlay(); }}
          var ro = new ResizeObserver(resize); ro.observe(host); resize();
          function drawOverlay(){ var r = host.getBoundingClientRect(); overlay.width = (r.width*dpr)|0; overlay.height = (r.height*dpr)|0; var ctx = overlay.getContext('2d'); ctx.clearRect(0,0,overlay.width,overlay.height); if(!options.showOverlay) return; ctx.save(); ctx.scale(dpr,dpr); var hf = options.hfovDeg*Math.PI/180; var v = Camera.state.video; var vf = hfovToVfov(hf, ((v && v.videoWidth)||16)/((v && v.videoHeight)||9)); var marks = [ -60, -45, -30, 0, 30, 45, 60 ]; ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.fillStyle='rgba(230,235,245,.8)'; ctx.font='600 10px system-ui'; ctx.textAlign='center'; marks.forEach(function(deg){ var u = 0.5 + (deg*Math.PI/180)/hf; var x = u * r.width; ctx.beginPath(); ctx.moveTo(x, 4); ctx.lineTo(x, r.height-4); ctx.stroke(); ctx.fillText(String(deg)+' deg', x, r.height-8); }); ctx.beginPath(); ctx.moveTo(4, r.height/2); ctx.lineTo(r.width-4, r.height/2); ctx.stroke(); ctx.restore(); }
          var t0 = performance.now();
          function frame(now){ var v = Camera.state.video; if(!v){ requestAnimationFrame(frame); return; } gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, glx.tex); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,v); }catch(e){} var r = host.getBoundingClientRect(); gl.uniform2f(glx.uniforms.uRes, r.width, r.height); gl.uniform1i(glx.uniforms.uCam, 0); gl.uniform2f(glx.uniforms.uCamSize, v.videoWidth||640, v.videoHeight||480); var hf = options.hfovDeg*Math.PI/180; var vf = hfovToVfov(hf, (v.videoWidth||16)/(v.videoHeight||9)); gl.uniform1f(glx.uniforms.uHFov, hf); gl.uniform1f(glx.uniforms.uVFov, vf); gl.uniform1f(glx.uniforms.uFlip, options.flip?1.0:0.0); gl.uniform1f(glx.uniforms.uRipple, options.ripple); gl.uniform1f(glx.uniforms.uRound, options.roundHint); gl.uniform1f(glx.uniforms.uTime, (now - t0)/1000); gl.drawArrays(gl.TRIANGLES, 0, 6); requestAnimationFrame(frame); }
          requestAnimationFrame(frame);
          instances.set(host, { host:host, canvas:canvas, overlay:overlay, glx:glx, options:options, resize:resize, drawOverlay:drawOverlay });
          return instances.get(host);
        }
        async function applyTo(selector, options){
          selector = selector || '.env-button';
          await Camera.ensure();
          var nodes = document.querySelectorAll(selector);
          for (var i=0;i<nodes.length;i++){ var el = nodes[i]; if(!el.__envBtn){ el.__envBtn = create(el, options); } }
        }
        function mapAnglesToPixel(azDeg, elDeg){ var v = Camera.state.video; if(!v) return null; var hf = currentHFOVRad(); var vf = 2*Math.atan(Math.tan(hf/2)/((v.videoWidth||16)/(v.videoHeight||9))); var uu = 0.5 + (azDeg*Math.PI/180)/hf; var w = v.videoWidth || 640; var h = v.videoHeight || 480; var vv = 0.5 - (elDeg*Math.PI/180)/vf; return { u:Math.max(0,Math.min(1,uu)), v:Math.max(0,Math.min(1,vv)), x: uu*w, y: vv*h, w: w, h: h }; }
        function currentHFOVRad(){ var it = instances.values().next(); var any = it && it.value; return ((any? any.options.hfovDeg:75) * Math.PI/180); }
        return { applyTo:applyTo, instances:instances, mapAnglesToPixel:mapAnglesToPixel };
      })();
    }

    /* Demo bootstrap */
    document.addEventListener('DOMContentLoaded', function(){
      (async function(){
        try{
          await window.EnvButtons.applyTo('.env-button', { hfovDeg: 75, ripple: 0.25, flip: true, showOverlay: true });
        }catch(e){ console.error('EnvButtons.applyTo failed:', e); }
        var hfov = document.getElementById('hfov'); var hfovVal = document.getElementById('hfovVal');
        var ripple = document.getElementById('ripple'); var rippleVal = document.getElementById('rippleVal');
        var overlayBtn = document.getElementById('toggleOverlay'); var flipBtn = document.getElementById('flip');
        hfov.addEventListener('input', function(){ var deg = +hfov.value; hfovVal.textContent = deg+' deg'; window.EnvButtons.instances.forEach(function(inst){ inst.options.hfovDeg = deg; inst.drawOverlay(); }); });
        ripple.addEventListener('input', function(){ var rv = +ripple.value; rippleVal.textContent = rv.toFixed(2); window.EnvButtons.instances.forEach(function(inst){ inst.options.ripple = rv; }); });
        overlayBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.showOverlay = !inst.options.showOverlay; inst.drawOverlay(); }); });
        flipBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.flip = !inst.options.flip; inst.drawOverlay(); }); });
        setTimeout(function(){ var p = window.EnvButtons.mapAnglesToPixel(45, 0); console.log('45 deg azimuth maps to webcam pixel:', p); }, 1200);
      })();
    });
  })();
  </script>
</body>
</html><!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Liquid Mirror — Hemi Env Buttons (stable)</title>
  <style>
    :root { --bg:#0e0f12; --card:#16181d; --fg:#e6e9ef; --muted:#9aa3b2; }
    html, body { height:100%; }
    body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:radial-gradient(80% 100% at 50% 0%, #13151a, #0b0c0f 70%); color:var(--fg); display:grid; place-items:center; padding:32px; }
    .wrap { display:grid; gap:24px; grid-template-columns: minmax(260px, 420px) 1fr; width:min(1200px, 94vw); align-items:start; }
    .card { background:var(--card); border:1px solid #23262d; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25) inset, 0 10px 40px rgba(0,0,0,.4); }
    .controls { display:grid; gap:12px; }
    .row { display:grid; gap:10px; }
    .row.cols-2 { grid-template-columns: 1fr 1fr; }
    label { display:grid; gap:6px; font-weight:600; }
    input[type="range"] { width:100%; }
    .btn { display:inline-flex; align-items:center; gap:10px; padding:10px 12px; border-radius: 10px; border:1px solid #272a31; background:#15171b; color:#e6ebf3; cursor:pointer; }
    .btn:hover { background:#1a1d22; }
    code{ background:#0f1114; border:1px solid #252831; padding:2px 6px; border-radius:6px; }

    .env-button { position:relative; overflow:hidden; border-radius:18px; display:grid; place-items:center; padding:18px 22px; background:#0b0c0f; isolation:isolate; }
    .env-button > canvas, .env-button > .overlay { position:absolute; inset:0; width:100%; height:100%; display:block; pointer-events:none; }
    .env-button > .overlay { z-index: 2; }
    .env-button > .content { position:relative; z-index:3; display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.2px; }
    .env-button .sub { font-size:12px; color:#9aa3b2; font-weight:600; }

    .grid { display:grid; grid-template-columns:repeat(2, minmax(240px, 1fr)); gap:16px; }
    .chip { background: #111317; padding:6px 10px; border-radius:10px; border:1px solid #2a2f37; color:#aeb6c6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2 style="margin:4px 0 8px;">Liquid Mirror — Hemi Env Buttons</h2>
      <p class="muted">Webcam as a live front-hemisphere environment map for glossy "liquid glass" UI elements. Includes angle zones (0, ±30, ±45, ±60) overlay and FOV calibration.</p>
      <div class="controls">
        <div class="row cols-2">
          <label>Horizontal FOV (deg)
            <input id="hfov" type="range" min="40" max="110" step="1" value="75">
            <div class="chip" id="hfovVal">75 deg</div>
          </label>
          <label>Liquid ripple
            <input id="ripple" type="range" min="0" max="1" step="0.01" value="0.25">
            <div class="chip" id="rippleVal">0.25</div>
          </label>
        </div>
        <div class="row cols-2">
          <button class="btn" id="toggleOverlay">Toggle zones overlay</button>
          <button class="btn" id="flip">Flip webcam (mirror)</button>
        </div>
        <p class="muted">API: <code>EnvButtons.applyTo('.env-button', { hfovDeg:75, ripple:0.25, flip:true })</code></p>
      </div>
    </div>

    <div class="grid">
      <div class="env-button" id="btn1">
        <div class="content">Liquid Glass Button</div>
        <div class="sub content">live reflection from your room</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
      <div class="env-button" id="btn2" style="border-radius: 999px; aspect-ratio: 1;">
        <div class="content">Round Glass</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
    </div>
  </div>

  <script>
  (function(){
    "use strict";
    if (!window.EnvMirror) window.EnvMirror = {};

    /* Camera (guarded) */
    if (!window.EnvMirror.Camera) {
      var CS = { stream:null, video:null, ready:false };
      async function ensureCamera(){
        if (CS.ready && CS.video && !CS.video.paused) return CS;
        var constraints = { video: { facingMode:"user" }, audio:false };
        var stream = await navigator.mediaDevices.getUserMedia(constraints);
        var v = document.createElement("video");
        v.autoplay = true; v.playsInline = true; v.muted = true; v.srcObject = stream; await v.play();
        CS.stream = stream; CS.video = v; CS.ready = true; return CS;
      }
      window.EnvMirror.Camera = { ensure: ensureCamera, state: CS };
    }
    var Camera = window.EnvMirror.Camera;

    /* WebGL factory (guarded) */
    if (!window.EnvMirror.makeGL) {
      window.EnvMirror.makeGL = function(canvas){
        var gl = canvas.getContext("webgl", { alpha:true, antialias:true, premultipliedAlpha:true });
        if(!gl) throw new Error("WebGL not available");
        function compile(type, src){
          var s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
            var info = gl.getShaderInfoLog(s) || "unknown compile error";
            console.error("Shader compile error:", info, "\nSource:\n", src);
            throw new Error(info);
          }
          return s;
        }
        var vsSrc = [
          "attribute vec2 aPos;",
          "varying vec2 vUv;",
          "void main(){ vUv = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.,1.); }"
        ].join("\n");

        // IMPORTANT: build FS via Array.join to avoid concatenation mistakes
        var fsSrc = [
          "precision mediump float;",
          "varying vec2 vUv;",
          "uniform sampler2D uCam; uniform vec2 uCamSize; uniform vec2 uRes;",
          "uniform float uTime; uniform float uHFov; uniform float uVFov; uniform float uFlip;",
          "uniform float uRipple; uniform float uRound;",
          "float hash(vec2 p){ return fract(sin(dot(p, vec2(41.3,289.1)))*43758.5453); }",
          "float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1.,0.)), c=hash(i+vec2(0.,1.)), d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }",
          "float fbm(vec2 p){ float s=0., a=0.5; for(int i=0;i<4;i++){ s+=a*noise(p); p*=2.07; a*=0.5; } return s; }",
          "vec3 domeNormal(vec2 uv){",
          "  float aspect = uRes.x / max(uRes.y, 1.0);",
          "  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);",
          "  float r2 = dot(p,p);",
          "  float R = 0.5; float rr = min(sqrt(r2)/R, 0.999);",
          "  float z = sqrt(1.0 - rr*rr);",
          "  vec3 N = normalize(vec3(p.x/(R*R*z + 1e-5), p.y/(R*R*z + 1e-5), 1.0));",
          "  N = mix(normalize(vec3(0.6*p.x, 0.6*p.y, 1.0)), N, uRound);",
          "  return N;",
          "}",
          "vec2 sampleFromWebcam(vec3 R){",
          "  float phi = atan(R.x, R.z);",
          "  float theta = asin(clamp(R.y, -1.0, 1.0));",
          "  float u = 0.5 + phi / uHFov;",
          "  float v = 0.5 - theta / uVFov;",
          "  if (uFlip > 0.5) u = 1.0 - u;",
          "  return clamp(vec2(u, v), 0.0, 1.0);",
          "}",
          "void main(){",
          "  vec3 V = vec3(0.0, 0.0, 1.0);",
          "  vec3 N = domeNormal(vUv);",
          "  if (uRipple > 0.001){",
          "    float r = uRipple * 0.6; vec2 q = vUv * uRes.xy * 0.005 + vec2(0.0, uTime*0.2); float rip = fbm(q);",
          "    N.xy += (rip - 0.5) * r; N = normalize(N);",
          "  }",
          "  vec3 R = reflect(-V, N); R.z = max(R.z, 1e-3);",
          "  vec2 camUV = sampleFromWebcam(normalize(R));",
          "  vec3 env = texture2D(uCam, camUV).rgb;",
          "  float NdV = clamp(dot(N, V), 0.0, 1.0);",
          "  float F0 = 0.06; float F = F0 + (1.0 - F0) * pow(1.0 - NdV, 5.0);",
          "  vec3 tint = vec3(0.95, 0.98, 1.0);",
          "  vec3 col = mix(tint * 0.08, env, F);",
          "  float sheen = pow(1.0 - length((vUv - 0.5) * 2.0), 20.0) * 0.35; col += sheen;",
          "  gl_FragColor = vec4(col, 1.0);",
          "}"
        ].join("\n");

        var vs = compile(gl.VERTEX_SHADER, vsSrc);
        var fs = compile(gl.FRAGMENT_SHADER, fsSrc);
        var prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
        if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
        gl.useProgram(prog);
        var quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
        var aPos = gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
        var tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        function U(n){ return gl.getUniformLocation(prog, n); }
        var uniforms = { uCam:U('uCam'), uCamSize:U('uCamSize'), uRes:U('uRes'), uTime:U('uTime'), uHFov:U('uHFov'), uVFov:U('uVFov'), uFlip:U('uFlip'), uRipple:U('uRipple'), uRound:U('uRound') };
        return { gl:gl, prog:prog, tex:tex, uniforms:uniforms };
      };
    }
    var makeGL = window.EnvMirror.makeGL;

    /* EnvButtons (guarded) */
    if (!window.EnvButtons) {
      window.EnvButtons = (function(){
        var instances = new Map();
        function hfovToVfov(hfov, aspect){ return 2*Math.atan(Math.tan(hfov/2)/aspect); }
        function create(host, opts){
          var options = Object.assign({ hfovDeg:75, ripple:0.25, flip:true, roundHint:0.6, showOverlay:true }, opts||{});
          var canvas = host.querySelector('canvas'); var overlay = host.querySelector('.overlay');
          var glx = makeGL(canvas); var gl = glx.gl;
          var dpr = Math.max(1, window.devicePixelRatio||1);
          function resize(){ var r = host.getBoundingClientRect(); var W = Math.max(1,(r.width*dpr)|0), H = Math.max(1,(r.height*dpr)|0); if(canvas.width!==W||canvas.height!==H){ canvas.width=W; canvas.height=H; gl.viewport(0,0,W,H); drawOverlay(); }}
          var ro = new ResizeObserver(resize); ro.observe(host); resize();
          function drawOverlay(){ var r = host.getBoundingClientRect(); overlay.width = (r.width*dpr)|0; overlay.height = (r.height*dpr)|0; var ctx = overlay.getContext('2d'); ctx.clearRect(0,0,overlay.width,overlay.height); if(!options.showOverlay) return; ctx.save(); ctx.scale(dpr,dpr); var hf = options.hfovDeg*Math.PI/180; var v = Camera.state.video; var vf = hfovToVfov(hf, ((v && v.videoWidth)||16)/((v && v.videoHeight)||9)); var marks = [ -60, -45, -30, 0, 30, 45, 60 ]; ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.fillStyle='rgba(230,235,245,.8)'; ctx.font='600 10px system-ui'; ctx.textAlign='center'; marks.forEach(function(deg){ var u = 0.5 + (deg*Math.PI/180)/hf; var x = u * r.width; ctx.beginPath(); ctx.moveTo(x, 4); ctx.lineTo(x, r.height-4); ctx.stroke(); ctx.fillText(String(deg)+' deg', x, r.height-8); }); ctx.beginPath(); ctx.moveTo(4, r.height/2); ctx.lineTo(r.width-4, r.height/2); ctx.stroke(); ctx.restore(); }
          var t0 = performance.now();
          function frame(now){ var v = Camera.state.video; if(!v){ requestAnimationFrame(frame); return; } gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, glx.tex); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,v); }catch(e){} var r = host.getBoundingClientRect(); gl.uniform2f(glx.uniforms.uRes, r.width, r.height); gl.uniform1i(glx.uniforms.uCam, 0); gl.uniform2f(glx.uniforms.uCamSize, v.videoWidth||640, v.videoHeight||480); var hf = options.hfovDeg*Math.PI/180; var vf = hfovToVfov(hf, (v.videoWidth||16)/(v.videoHeight||9)); gl.uniform1f(glx.uniforms.uHFov, hf); gl.uniform1f(glx.uniforms.uVFov, vf); gl.uniform1f(glx.uniforms.uFlip, options.flip?1.0:0.0); gl.uniform1f(glx.uniforms.uRipple, options.ripple); gl.uniform1f(glx.uniforms.uRound, options.roundHint); gl.uniform1f(glx.uniforms.uTime, (now - t0)/1000); gl.drawArrays(gl.TRIANGLES, 0, 6); requestAnimationFrame(frame); }
          requestAnimationFrame(frame);
          instances.set(host, { host:host, canvas:canvas, overlay:overlay, glx:glx, options:options, resize:resize, drawOverlay:drawOverlay });
          return instances.get(host);
        }
        async function applyTo(selector, options){
          selector = selector || '.env-button';
          await Camera.ensure();
          var nodes = document.querySelectorAll(selector);
          for (var i=0;i<nodes.length;i++){ var el = nodes[i]; if(!el.__envBtn){ el.__envBtn = create(el, options); } }
        }
        function mapAnglesToPixel(azDeg, elDeg){ var v = Camera.state.video; if(!v) return null; var hf = currentHFOVRad(); var vf = 2*Math.atan(Math.tan(hf/2)/((v.videoWidth||16)/(v.videoHeight||9))); var uu = 0.5 + (azDeg*Math.PI/180)/hf; var w = v.videoWidth || 640; var h = v.videoHeight || 480; var vv = 0.5 - (elDeg*Math.PI/180)/vf; return { u:Math.max(0,Math.min(1,uu)), v:Math.max(0,Math.min(1,vv)), x: uu*w, y: vv*h, w: w, h: h }; }
        function currentHFOVRad(){ var it = instances.values().next(); var any = it && it.value; return ((any? any.options.hfovDeg:75) * Math.PI/180); }
        return { applyTo:applyTo, instances:instances, mapAnglesToPixel:mapAnglesToPixel };
      })();
    }

    /* Demo bootstrap */
    document.addEventListener('DOMContentLoaded', function(){
      (async function(){
        try{
          await window.EnvButtons.applyTo('.env-button', { hfovDeg: 75, ripple: 0.25, flip: true, showOverlay: true });
        }catch(e){ console.error('EnvButtons.applyTo failed:', e); }
        var hfov = document.getElementById('hfov'); var hfovVal = document.getElementById('hfovVal');
        var ripple = document.getElementById('ripple'); var rippleVal = document.getElementById('rippleVal');
        var overlayBtn = document.getElementById('toggleOverlay'); var flipBtn = document.getElementById('flip');
        hfov.addEventListener('input', function(){ var deg = +hfov.value; hfovVal.textContent = deg+' deg'; window.EnvButtons.instances.forEach(function(inst){ inst.options.hfovDeg = deg; inst.drawOverlay(); }); });
        ripple.addEventListener('input', function(){ var rv = +ripple.value; rippleVal.textContent = rv.toFixed(2); window.EnvButtons.instances.forEach(function(inst){ inst.options.ripple = rv; }); });
        overlayBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.showOverlay = !inst.options.showOverlay; inst.drawOverlay(); }); });
        flipBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.flip = !inst.options.flip; inst.drawOverlay(); }); });
        setTimeout(function(){ var p = window.EnvButtons.mapAnglesToPixel(45, 0); console.log('45 deg azimuth maps to webcam pixel:', p); }, 1200);
      })();
    });
  })();
  </script>
</body>
</html><!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Liquid Mirror — Hemi Env Buttons (stable)</title>
  <style>
    :root { --bg:#0e0f12; --card:#16181d; --fg:#e6e9ef; --muted:#9aa3b2; }
    html, body { height:100%; }
    body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:radial-gradient(80% 100% at 50% 0%, #13151a, #0b0c0f 70%); color:var(--fg); display:grid; place-items:center; padding:32px; }
    .wrap { display:grid; gap:24px; grid-template-columns: minmax(260px, 420px) 1fr; width:min(1200px, 94vw); align-items:start; }
    .card { background:var(--card); border:1px solid #23262d; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25) inset, 0 10px 40px rgba(0,0,0,.4); }
    .controls { display:grid; gap:12px; }
    .row { display:grid; gap:10px; }
    .row.cols-2 { grid-template-columns: 1fr 1fr; }
    label { display:grid; gap:6px; font-weight:600; }
    input[type="range"] { width:100%; }
    .btn { display:inline-flex; align-items:center; gap:10px; padding:10px 12px; border-radius: 10px; border:1px solid #272a31; background:#15171b; color:#e6ebf3; cursor:pointer; }
    .btn:hover { background:#1a1d22; }
    code{ background:#0f1114; border:1px solid #252831; padding:2px 6px; border-radius:6px; }

    .env-button { position:relative; overflow:hidden; border-radius:18px; display:grid; place-items:center; padding:18px 22px; background:#0b0c0f; isolation:isolate; }
    .env-button > canvas, .env-button > .overlay { position:absolute; inset:0; width:100%; height:100%; display:block; pointer-events:none; }
    .env-button > .overlay { z-index: 2; }
    .env-button > .content { position:relative; z-index:3; display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.2px; }
    .env-button .sub { font-size:12px; color:#9aa3b2; font-weight:600; }

    .grid { display:grid; grid-template-columns:repeat(2, minmax(240px, 1fr)); gap:16px; }
    .chip { background: #111317; padding:6px 10px; border-radius:10px; border:1px solid #2a2f37; color:#aeb6c6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2 style="margin:4px 0 8px;">Liquid Mirror — Hemi Env Buttons</h2>
      <p class="muted">Webcam as a live front-hemisphere environment map for glossy "liquid glass" UI elements. Includes angle zones (0, ±30, ±45, ±60) overlay and FOV calibration.</p>
      <div class="controls">
        <div class="row cols-2">
          <label>Horizontal FOV (deg)
            <input id="hfov" type="range" min="40" max="110" step="1" value="75">
            <div class="chip" id="hfovVal">75 deg</div>
          </label>
          <label>Liquid ripple
            <input id="ripple" type="range" min="0" max="1" step="0.01" value="0.25">
            <div class="chip" id="rippleVal">0.25</div>
          </label>
        </div>
        <div class="row cols-2">
          <button class="btn" id="toggleOverlay">Toggle zones overlay</button>
          <button class="btn" id="flip">Flip webcam (mirror)</button>
        </div>
        <p class="muted">API: <code>EnvButtons.applyTo('.env-button', { hfovDeg:75, ripple:0.25, flip:true })</code></p>
      </div>
    </div>

    <div class="grid">
      <div class="env-button" id="btn1">
        <div class="content">Liquid Glass Button</div>
        <div class="sub content">live reflection from your room</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
      <div class="env-button" id="btn2" style="border-radius: 999px; aspect-ratio: 1;">
        <div class="content">Round Glass</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
    </div>
  </div>

  <script>
  (function(){
    "use strict";
    if (!window.EnvMirror) window.EnvMirror = {};

    /* Camera (guarded) */
    if (!window.EnvMirror.Camera) {
      var CS = { stream:null, video:null, ready:false };
      async function ensureCamera(){
        if (CS.ready && CS.video && !CS.video.paused) return CS;
        var constraints = { video: { facingMode:"user" }, audio:false };
        var stream = await navigator.mediaDevices.getUserMedia(constraints);
        var v = document.createElement("video");
        v.autoplay = true; v.playsInline = true; v.muted = true; v.srcObject = stream; await v.play();
        CS.stream = stream; CS.video = v; CS.ready = true; return CS;
      }
      window.EnvMirror.Camera = { ensure: ensureCamera, state: CS };
    }
    var Camera = window.EnvMirror.Camera;

    /* WebGL factory (guarded) */
    if (!window.EnvMirror.makeGL) {
      window.EnvMirror.makeGL = function(canvas){
        var gl = canvas.getContext("webgl", { alpha:true, antialias:true, premultipliedAlpha:true });
        if(!gl) throw new Error("WebGL not available");
        function compile(type, src){
          var s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
            var info = gl.getShaderInfoLog(s) || "unknown compile error";
            console.error("Shader compile error:", info, "\nSource:\n", src);
            throw new Error(info);
          }
          return s;
        }
        var vsSrc = [
          "attribute vec2 aPos;",
          "varying vec2 vUv;",
          "void main(){ vUv = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.,1.); }"
        ].join("\n");

        // IMPORTANT: build FS via Array.join to avoid concatenation mistakes
        var fsSrc = [
          "precision mediump float;",
          "varying vec2 vUv;",
          "uniform sampler2D uCam; uniform vec2 uCamSize; uniform vec2 uRes;",
          "uniform float uTime; uniform float uHFov; uniform float uVFov; uniform float uFlip;",
          "uniform float uRipple; uniform float uRound;",
          "float hash(vec2 p){ return fract(sin(dot(p, vec2(41.3,289.1)))*43758.5453); }",
          "float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1.,0.)), c=hash(i+vec2(0.,1.)), d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }",
          "float fbm(vec2 p){ float s=0., a=0.5; for(int i=0;i<4;i++){ s+=a*noise(p); p*=2.07; a*=0.5; } return s; }",
          "vec3 domeNormal(vec2 uv){",
          "  float aspect = uRes.x / max(uRes.y, 1.0);",
          "  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);",
          "  float r2 = dot(p,p);",
          "  float R = 0.5; float rr = min(sqrt(r2)/R, 0.999);",
          "  float z = sqrt(1.0 - rr*rr);",
          "  vec3 N = normalize(vec3(p.x/(R*R*z + 1e-5), p.y/(R*R*z + 1e-5), 1.0));",
          "  N = mix(normalize(vec3(0.6*p.x, 0.6*p.y, 1.0)), N, uRound);",
          "  return N;",
          "}",
          "vec2 sampleFromWebcam(vec3 R){",
          "  float phi = atan(R.x, R.z);",
          "  float theta = asin(clamp(R.y, -1.0, 1.0));",
          "  float u = 0.5 + phi / uHFov;",
          "  float v = 0.5 - theta / uVFov;",
          "  if (uFlip > 0.5) u = 1.0 - u;",
          "  return clamp(vec2(u, v), 0.0, 1.0);",
          "}",
          "void main(){",
          "  vec3 V = vec3(0.0, 0.0, 1.0);",
          "  vec3 N = domeNormal(vUv);",
          "  if (uRipple > 0.001){",
          "    float r = uRipple * 0.6; vec2 q = vUv * uRes.xy * 0.005 + vec2(0.0, uTime*0.2); float rip = fbm(q);",
          "    N.xy += (rip - 0.5) * r; N = normalize(N);",
          "  }",
          "  vec3 R = reflect(-V, N); R.z = max(R.z, 1e-3);",
          "  vec2 camUV = sampleFromWebcam(normalize(R));",
          "  vec3 env = texture2D(uCam, camUV).rgb;",
          "  float NdV = clamp(dot(N, V), 0.0, 1.0);",
          "  float F0 = 0.06; float F = F0 + (1.0 - F0) * pow(1.0 - NdV, 5.0);",
          "  vec3 tint = vec3(0.95, 0.98, 1.0);",
          "  vec3 col = mix(tint * 0.08, env, F);",
          "  float sheen = pow(1.0 - length((vUv - 0.5) * 2.0), 20.0) * 0.35; col += sheen;",
          "  gl_FragColor = vec4(col, 1.0);",
          "}"
        ].join("\n");

        var vs = compile(gl.VERTEX_SHADER, vsSrc);
        var fs = compile(gl.FRAGMENT_SHADER, fsSrc);
        var prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
        if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
        gl.useProgram(prog);
        var quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
        var aPos = gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
        var tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        function U(n){ return gl.getUniformLocation(prog, n); }
        var uniforms = { uCam:U('uCam'), uCamSize:U('uCamSize'), uRes:U('uRes'), uTime:U('uTime'), uHFov:U('uHFov'), uVFov:U('uVFov'), uFlip:U('uFlip'), uRipple:U('uRipple'), uRound:U('uRound') };
        return { gl:gl, prog:prog, tex:tex, uniforms:uniforms };
      };
    }
    var makeGL = window.EnvMirror.makeGL;

    /* EnvButtons (guarded) */
    if (!window.EnvButtons) {
      window.EnvButtons = (function(){
        var instances = new Map();
        function hfovToVfov(hfov, aspect){ return 2*Math.atan(Math.tan(hfov/2)/aspect); }
        function create(host, opts){
          var options = Object.assign({ hfovDeg:75, ripple:0.25, flip:true, roundHint:0.6, showOverlay:true }, opts||{});
          var canvas = host.querySelector('canvas'); var overlay = host.querySelector('.overlay');
          var glx = makeGL(canvas); var gl = glx.gl;
          var dpr = Math.max(1, window.devicePixelRatio||1);
          function resize(){ var r = host.getBoundingClientRect(); var W = Math.max(1,(r.width*dpr)|0), H = Math.max(1,(r.height*dpr)|0); if(canvas.width!==W||canvas.height!==H){ canvas.width=W; canvas.height=H; gl.viewport(0,0,W,H); drawOverlay(); }}
          var ro = new ResizeObserver(resize); ro.observe(host); resize();
          function drawOverlay(){ var r = host.getBoundingClientRect(); overlay.width = (r.width*dpr)|0; overlay.height = (r.height*dpr)|0; var ctx = overlay.getContext('2d'); ctx.clearRect(0,0,overlay.width,overlay.height); if(!options.showOverlay) return; ctx.save(); ctx.scale(dpr,dpr); var hf = options.hfovDeg*Math.PI/180; var v = Camera.state.video; var vf = hfovToVfov(hf, ((v && v.videoWidth)||16)/((v && v.videoHeight)||9)); var marks = [ -60, -45, -30, 0, 30, 45, 60 ]; ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.fillStyle='rgba(230,235,245,.8)'; ctx.font='600 10px system-ui'; ctx.textAlign='center'; marks.forEach(function(deg){ var u = 0.5 + (deg*Math.PI/180)/hf; var x = u * r.width; ctx.beginPath(); ctx.moveTo(x, 4); ctx.lineTo(x, r.height-4); ctx.stroke(); ctx.fillText(String(deg)+' deg', x, r.height-8); }); ctx.beginPath(); ctx.moveTo(4, r.height/2); ctx.lineTo(r.width-4, r.height/2); ctx.stroke(); ctx.restore(); }
          var t0 = performance.now();
          function frame(now){ var v = Camera.state.video; if(!v){ requestAnimationFrame(frame); return; } gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, glx.tex); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,v); }catch(e){} var r = host.getBoundingClientRect(); gl.uniform2f(glx.uniforms.uRes, r.width, r.height); gl.uniform1i(glx.uniforms.uCam, 0); gl.uniform2f(glx.uniforms.uCamSize, v.videoWidth||640, v.videoHeight||480); var hf = options.hfovDeg*Math.PI/180; var vf = hfovToVfov(hf, (v.videoWidth||16)/(v.videoHeight||9)); gl.uniform1f(glx.uniforms.uHFov, hf); gl.uniform1f(glx.uniforms.uVFov, vf); gl.uniform1f(glx.uniforms.uFlip, options.flip?1.0:0.0); gl.uniform1f(glx.uniforms.uRipple, options.ripple); gl.uniform1f(glx.uniforms.uRound, options.roundHint); gl.uniform1f(glx.uniforms.uTime, (now - t0)/1000); gl.drawArrays(gl.TRIANGLES, 0, 6); requestAnimationFrame(frame); }
          requestAnimationFrame(frame);
          instances.set(host, { host:host, canvas:canvas, overlay:overlay, glx:glx, options:options, resize:resize, drawOverlay:drawOverlay });
          return instances.get(host);
        }
        async function applyTo(selector, options){
          selector = selector || '.env-button';
          await Camera.ensure();
          var nodes = document.querySelectorAll(selector);
          for (var i=0;i<nodes.length;i++){ var el = nodes[i]; if(!el.__envBtn){ el.__envBtn = create(el, options); } }
        }
        function mapAnglesToPixel(azDeg, elDeg){ var v = Camera.state.video; if(!v) return null; var hf = currentHFOVRad(); var vf = 2*Math.atan(Math.tan(hf/2)/((v.videoWidth||16)/(v.videoHeight||9))); var uu = 0.5 + (azDeg*Math.PI/180)/hf; var w = v.videoWidth || 640; var h = v.videoHeight || 480; var vv = 0.5 - (elDeg*Math.PI/180)/vf; return { u:Math.max(0,Math.min(1,uu)), v:Math.max(0,Math.min(1,vv)), x: uu*w, y: vv*h, w: w, h: h }; }
        function currentHFOVRad(){ var it = instances.values().next(); var any = it && it.value; return ((any? any.options.hfovDeg:75) * Math.PI/180); }
        return { applyTo:applyTo, instances:instances, mapAnglesToPixel:mapAnglesToPixel };
      })();
    }

    /* Demo bootstrap */
    document.addEventListener('DOMContentLoaded', function(){
      (async function(){
        try{
          await window.EnvButtons.applyTo('.env-button', { hfovDeg: 75, ripple: 0.25, flip: true, showOverlay: true });
        }catch(e){ console.error('EnvButtons.applyTo failed:', e); }
        var hfov = document.getElementById('hfov'); var hfovVal = document.getElementById('hfovVal');
        var ripple = document.getElementById('ripple'); var rippleVal = document.getElementById('rippleVal');
        var overlayBtn = document.getElementById('toggleOverlay'); var flipBtn = document.getElementById('flip');
        hfov.addEventListener('input', function(){ var deg = +hfov.value; hfovVal.textContent = deg+' deg'; window.EnvButtons.instances.forEach(function(inst){ inst.options.hfovDeg = deg; inst.drawOverlay(); }); });
        ripple.addEventListener('input', function(){ var rv = +ripple.value; rippleVal.textContent = rv.toFixed(2); window.EnvButtons.instances.forEach(function(inst){ inst.options.ripple = rv; }); });
        overlayBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.showOverlay = !inst.options.showOverlay; inst.drawOverlay(); }); });
        flipBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.flip = !inst.options.flip; inst.drawOverlay(); }); });
        setTimeout(function(){ var p = window.EnvButtons.mapAnglesToPixel(45, 0); console.log('45 deg azimuth maps to webcam pixel:', p); }, 1200);
      })();
    });
  })();
  </script>
</body>
</html><!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Liquid Mirror — Hemi Env Buttons (stable)</title>
  <style>
    :root { --bg:#0e0f12; --card:#16181d; --fg:#e6e9ef; --muted:#9aa3b2; }
    html, body { height:100%; }
    body { margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; background:radial-gradient(80% 100% at 50% 0%, #13151a, #0b0c0f 70%); color:var(--fg); display:grid; place-items:center; padding:32px; }
    .wrap { display:grid; gap:24px; grid-template-columns: minmax(260px, 420px) 1fr; width:min(1200px, 94vw); align-items:start; }
    .card { background:var(--card); border:1px solid #23262d; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25) inset, 0 10px 40px rgba(0,0,0,.4); }
    .controls { display:grid; gap:12px; }
    .row { display:grid; gap:10px; }
    .row.cols-2 { grid-template-columns: 1fr 1fr; }
    label { display:grid; gap:6px; font-weight:600; }
    input[type="range"] { width:100%; }
    .btn { display:inline-flex; align-items:center; gap:10px; padding:10px 12px; border-radius: 10px; border:1px solid #272a31; background:#15171b; color:#e6ebf3; cursor:pointer; }
    .btn:hover { background:#1a1d22; }
    code{ background:#0f1114; border:1px solid #252831; padding:2px 6px; border-radius:6px; }

    .env-button { position:relative; overflow:hidden; border-radius:18px; display:grid; place-items:center; padding:18px 22px; background:#0b0c0f; isolation:isolate; }
    .env-button > canvas, .env-button > .overlay { position:absolute; inset:0; width:100%; height:100%; display:block; pointer-events:none; }
    .env-button > .overlay { z-index: 2; }
    .env-button > .content { position:relative; z-index:3; display:flex; align-items:center; gap:10px; font-weight:700; letter-spacing:.2px; }
    .env-button .sub { font-size:12px; color:#9aa3b2; font-weight:600; }

    .grid { display:grid; grid-template-columns:repeat(2, minmax(240px, 1fr)); gap:16px; }
    .chip { background: #111317; padding:6px 10px; border-radius:10px; border:1px solid #2a2f37; color:#aeb6c6; }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2 style="margin:4px 0 8px;">Liquid Mirror — Hemi Env Buttons</h2>
      <p class="muted">Webcam as a live front-hemisphere environment map for glossy "liquid glass" UI elements. Includes angle zones (0, ±30, ±45, ±60) overlay and FOV calibration.</p>
      <div class="controls">
        <div class="row cols-2">
          <label>Horizontal FOV (deg)
            <input id="hfov" type="range" min="40" max="110" step="1" value="75">
            <div class="chip" id="hfovVal">75 deg</div>
          </label>
          <label>Liquid ripple
            <input id="ripple" type="range" min="0" max="1" step="0.01" value="0.25">
            <div class="chip" id="rippleVal">0.25</div>
          </label>
        </div>
        <div class="row cols-2">
          <button class="btn" id="toggleOverlay">Toggle zones overlay</button>
          <button class="btn" id="flip">Flip webcam (mirror)</button>
        </div>
        <p class="muted">API: <code>EnvButtons.applyTo('.env-button', { hfovDeg:75, ripple:0.25, flip:true })</code></p>
      </div>
    </div>

    <div class="grid">
      <div class="env-button" id="btn1">
        <div class="content">Liquid Glass Button</div>
        <div class="sub content">live reflection from your room</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
      <div class="env-button" id="btn2" style="border-radius: 999px; aspect-ratio: 1;">
        <div class="content">Round Glass</div>
        <canvas></canvas>
        <canvas class="overlay"></canvas>
      </div>
    </div>
  </div>

  <script>
  (function(){
    "use strict";
    if (!window.EnvMirror) window.EnvMirror = {};

    /* Camera (guarded) */
    if (!window.EnvMirror.Camera) {
      var CS = { stream:null, video:null, ready:false };
      async function ensureCamera(){
        if (CS.ready && CS.video && !CS.video.paused) return CS;
        var constraints = { video: { facingMode:"user" }, audio:false };
        var stream = await navigator.mediaDevices.getUserMedia(constraints);
        var v = document.createElement("video");
        v.autoplay = true; v.playsInline = true; v.muted = true; v.srcObject = stream; await v.play();
        CS.stream = stream; CS.video = v; CS.ready = true; return CS;
      }
      window.EnvMirror.Camera = { ensure: ensureCamera, state: CS };
    }
    var Camera = window.EnvMirror.Camera;

    /* WebGL factory (guarded) */
    if (!window.EnvMirror.makeGL) {
      window.EnvMirror.makeGL = function(canvas){
        var gl = canvas.getContext("webgl", { alpha:true, antialias:true, premultipliedAlpha:true });
        if(!gl) throw new Error("WebGL not available");
        function compile(type, src){
          var s = gl.createShader(type);
          gl.shaderSource(s, src);
          gl.compileShader(s);
          if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
            var info = gl.getShaderInfoLog(s) || "unknown compile error";
            console.error("Shader compile error:", info, "\nSource:\n", src);
            throw new Error(info);
          }
          return s;
        }
        var vsSrc = [
          "attribute vec2 aPos;",
          "varying vec2 vUv;",
          "void main(){ vUv = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.,1.); }"
        ].join("\n");

        // IMPORTANT: build FS via Array.join to avoid concatenation mistakes
        var fsSrc = [
          "precision mediump float;",
          "varying vec2 vUv;",
          "uniform sampler2D uCam; uniform vec2 uCamSize; uniform vec2 uRes;",
          "uniform float uTime; uniform float uHFov; uniform float uVFov; uniform float uFlip;",
          "uniform float uRipple; uniform float uRound;",
          "float hash(vec2 p){ return fract(sin(dot(p, vec2(41.3,289.1)))*43758.5453); }",
          "float noise(vec2 p){ vec2 i=floor(p), f=fract(p); float a=hash(i), b=hash(i+vec2(1.,0.)), c=hash(i+vec2(0.,1.)), d=hash(i+vec2(1.,1.)); vec2 u=f*f*(3.-2.*f); return mix(a,b,u.x)+(c-a)*u.y*(1.-u.x)+(d-b)*u.x*u.y; }",
          "float fbm(vec2 p){ float s=0., a=0.5; for(int i=0;i<4;i++){ s+=a*noise(p); p*=2.07; a*=0.5; } return s; }",
          "vec3 domeNormal(vec2 uv){",
          "  float aspect = uRes.x / max(uRes.y, 1.0);",
          "  vec2 p = (uv - 0.5) * vec2(aspect, 1.0);",
          "  float r2 = dot(p,p);",
          "  float R = 0.5; float rr = min(sqrt(r2)/R, 0.999);",
          "  float z = sqrt(1.0 - rr*rr);",
          "  vec3 N = normalize(vec3(p.x/(R*R*z + 1e-5), p.y/(R*R*z + 1e-5), 1.0));",
          "  N = mix(normalize(vec3(0.6*p.x, 0.6*p.y, 1.0)), N, uRound);",
          "  return N;",
          "}",
          "vec2 sampleFromWebcam(vec3 R){",
          "  float phi = atan(R.x, R.z);",
          "  float theta = asin(clamp(R.y, -1.0, 1.0));",
          "  float u = 0.5 + phi / uHFov;",
          "  float v = 0.5 - theta / uVFov;",
          "  if (uFlip > 0.5) u = 1.0 - u;",
          "  return clamp(vec2(u, v), 0.0, 1.0);",
          "}",
          "void main(){",
          "  vec3 V = vec3(0.0, 0.0, 1.0);",
          "  vec3 N = domeNormal(vUv);",
          "  if (uRipple > 0.001){",
          "    float r = uRipple * 0.6; vec2 q = vUv * uRes.xy * 0.005 + vec2(0.0, uTime*0.2); float rip = fbm(q);",
          "    N.xy += (rip - 0.5) * r; N = normalize(N);",
          "  }",
          "  vec3 R = reflect(-V, N); R.z = max(R.z, 1e-3);",
          "  vec2 camUV = sampleFromWebcam(normalize(R));",
          "  vec3 env = texture2D(uCam, camUV).rgb;",
          "  float NdV = clamp(dot(N, V), 0.0, 1.0);",
          "  float F0 = 0.06; float F = F0 + (1.0 - F0) * pow(1.0 - NdV, 5.0);",
          "  vec3 tint = vec3(0.95, 0.98, 1.0);",
          "  vec3 col = mix(tint * 0.08, env, F);",
          "  float sheen = pow(1.0 - length((vUv - 0.5) * 2.0), 20.0) * 0.35; col += sheen;",
          "  gl_FragColor = vec4(col, 1.0);",
          "}"
        ].join("\n");

        var vs = compile(gl.VERTEX_SHADER, vsSrc);
        var fs = compile(gl.FRAGMENT_SHADER, fsSrc);
        var prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
        if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
        gl.useProgram(prog);
        var quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad);
        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1, -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
        var aPos = gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);
        var tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE); gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        function U(n){ return gl.getUniformLocation(prog, n); }
        var uniforms = { uCam:U('uCam'), uCamSize:U('uCamSize'), uRes:U('uRes'), uTime:U('uTime'), uHFov:U('uHFov'), uVFov:U('uVFov'), uFlip:U('uFlip'), uRipple:U('uRipple'), uRound:U('uRound') };
        return { gl:gl, prog:prog, tex:tex, uniforms:uniforms };
      };
    }
    var makeGL = window.EnvMirror.makeGL;

    /* EnvButtons (guarded) */
    if (!window.EnvButtons) {
      window.EnvButtons = (function(){
        var instances = new Map();
        function hfovToVfov(hfov, aspect){ return 2*Math.atan(Math.tan(hfov/2)/aspect); }
        function create(host, opts){
          var options = Object.assign({ hfovDeg:75, ripple:0.25, flip:true, roundHint:0.6, showOverlay:true }, opts||{});
          var canvas = host.querySelector('canvas'); var overlay = host.querySelector('.overlay');
          var glx = makeGL(canvas); var gl = glx.gl;
          var dpr = Math.max(1, window.devicePixelRatio||1);
          function resize(){ var r = host.getBoundingClientRect(); var W = Math.max(1,(r.width*dpr)|0), H = Math.max(1,(r.height*dpr)|0); if(canvas.width!==W||canvas.height!==H){ canvas.width=W; canvas.height=H; gl.viewport(0,0,W,H); drawOverlay(); }}
          var ro = new ResizeObserver(resize); ro.observe(host); resize();
          function drawOverlay(){ var r = host.getBoundingClientRect(); overlay.width = (r.width*dpr)|0; overlay.height = (r.height*dpr)|0; var ctx = overlay.getContext('2d'); ctx.clearRect(0,0,overlay.width,overlay.height); if(!options.showOverlay) return; ctx.save(); ctx.scale(dpr,dpr); var hf = options.hfovDeg*Math.PI/180; var v = Camera.state.video; var vf = hfovToVfov(hf, ((v && v.videoWidth)||16)/((v && v.videoHeight)||9)); var marks = [ -60, -45, -30, 0, 30, 45, 60 ]; ctx.strokeStyle='rgba(255,255,255,.22)'; ctx.fillStyle='rgba(230,235,245,.8)'; ctx.font='600 10px system-ui'; ctx.textAlign='center'; marks.forEach(function(deg){ var u = 0.5 + (deg*Math.PI/180)/hf; var x = u * r.width; ctx.beginPath(); ctx.moveTo(x, 4); ctx.lineTo(x, r.height-4); ctx.stroke(); ctx.fillText(String(deg)+' deg', x, r.height-8); }); ctx.beginPath(); ctx.moveTo(4, r.height/2); ctx.lineTo(r.width-4, r.height/2); ctx.stroke(); ctx.restore(); }
          var t0 = performance.now();
          function frame(now){ var v = Camera.state.video; if(!v){ requestAnimationFrame(frame); return; } gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, glx.tex); try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,v); }catch(e){} var r = host.getBoundingClientRect(); gl.uniform2f(glx.uniforms.uRes, r.width, r.height); gl.uniform1i(glx.uniforms.uCam, 0); gl.uniform2f(glx.uniforms.uCamSize, v.videoWidth||640, v.videoHeight||480); var hf = options.hfovDeg*Math.PI/180; var vf = hfovToVfov(hf, (v.videoWidth||16)/(v.videoHeight||9)); gl.uniform1f(glx.uniforms.uHFov, hf); gl.uniform1f(glx.uniforms.uVFov, vf); gl.uniform1f(glx.uniforms.uFlip, options.flip?1.0:0.0); gl.uniform1f(glx.uniforms.uRipple, options.ripple); gl.uniform1f(glx.uniforms.uRound, options.roundHint); gl.uniform1f(glx.uniforms.uTime, (now - t0)/1000); gl.drawArrays(gl.TRIANGLES, 0, 6); requestAnimationFrame(frame); }
          requestAnimationFrame(frame);
          instances.set(host, { host:host, canvas:canvas, overlay:overlay, glx:glx, options:options, resize:resize, drawOverlay:drawOverlay });
          return instances.get(host);
        }
        async function applyTo(selector, options){
          selector = selector || '.env-button';
          await Camera.ensure();
          var nodes = document.querySelectorAll(selector);
          for (var i=0;i<nodes.length;i++){ var el = nodes[i]; if(!el.__envBtn){ el.__envBtn = create(el, options); } }
        }
        function mapAnglesToPixel(azDeg, elDeg){ var v = Camera.state.video; if(!v) return null; var hf = currentHFOVRad(); var vf = 2*Math.atan(Math.tan(hf/2)/((v.videoWidth||16)/(v.videoHeight||9))); var uu = 0.5 + (azDeg*Math.PI/180)/hf; var w = v.videoWidth || 640; var h = v.videoHeight || 480; var vv = 0.5 - (elDeg*Math.PI/180)/vf; return { u:Math.max(0,Math.min(1,uu)), v:Math.max(0,Math.min(1,vv)), x: uu*w, y: vv*h, w: w, h: h }; }
        function currentHFOVRad(){ var it = instances.values().next(); var any = it && it.value; return ((any? any.options.hfovDeg:75) * Math.PI/180); }
        return { applyTo:applyTo, instances:instances, mapAnglesToPixel:mapAnglesToPixel };
      })();
    }

    /* Demo bootstrap */
    document.addEventListener('DOMContentLoaded', function(){
      (async function(){
        try{
          await window.EnvButtons.applyTo('.env-button', { hfovDeg: 75, ripple: 0.25, flip: true, showOverlay: true });
        }catch(e){ console.error('EnvButtons.applyTo failed:', e); }
        var hfov = document.getElementById('hfov'); var hfovVal = document.getElementById('hfovVal');
        var ripple = document.getElementById('ripple'); var rippleVal = document.getElementById('rippleVal');
        var overlayBtn = document.getElementById('toggleOverlay'); var flipBtn = document.getElementById('flip');
        hfov.addEventListener('input', function(){ var deg = +hfov.value; hfovVal.textContent = deg+' deg'; window.EnvButtons.instances.forEach(function(inst){ inst.options.hfovDeg = deg; inst.drawOverlay(); }); });
        ripple.addEventListener('input', function(){ var rv = +ripple.value; rippleVal.textContent = rv.toFixed(2); window.EnvButtons.instances.forEach(function(inst){ inst.options.ripple = rv; }); });
        overlayBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.showOverlay = !inst.options.showOverlay; inst.drawOverlay(); }); });
        flipBtn.addEventListener('click', function(){ window.EnvButtons.instances.forEach(function(inst){ inst.options.flip = !inst.options.flip; inst.drawOverlay(); }); });
        setTimeout(function(){ var p = window.EnvButtons.mapAnglesToPixel(45, 0); console.log('45 deg azimuth maps to webcam pixel:', p); }, 1200);
      })();
    });
  })();
  </script>
</body>
</html>