<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Mirror Debug — Focus Mapping + Smooth Corners</title>
<style>
  :root { --bg:#0e0f12; --card:#16181d; --fg:#e6e9ef; --muted:#9aa3b2; }
  html, body { height:100%; }
  body{margin:0;font:14px/1.45 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif;
       background:radial-gradient(80% 100% at 50% 0%, #13151a, #0b0c0f 70%);color:var(--fg);
       display:grid;place-items:center;padding:28px}
  .wrap{display:grid;gap:22px;grid-template-columns:minmax(360px,520px) 1fr;width:min(1300px,94vw);align-items:start}
  .card{background:#16181d;border:1px solid #23262d;border-radius:16px;padding:18px;box-shadow:0 10px 30px rgba(0,0,0,.25) inset,0 10px 40px rgba(0,0,0,.4)}
  h1{font-size:28px;line-height:1.15;margin:0 0 8px}
  .lede{color:#aeb6c6;margin:0 0 14px}
  .controls{display:grid;gap:12px}
  .row{display:grid;gap:10px}
  .row.cols-2{grid-template-columns:1fr 1fr}
  .row.cols-3{grid-template-columns:1fr 1fr 1fr}
  label{display:grid;gap:6px;font-weight:600}
  input[type="range"],select,input[type="color"]{width:100%}
  .btn{display:inline-flex;align-items:center;gap:10px;padding:10px 12px;border-radius:10px;border:1px solid #272a31;background:#15171b;color:#e6ebf3;cursor:pointer}
  .btn:hover{background:#1a1d22}
  .chip{background:#111317;padding:6px 10px;border-radius:10px;border:1px solid #2a2f37;color:#aeb6c6}
  .grid{display:grid;grid-template-columns:repeat(2,minmax(260px,1fr));gap:18px;align-items:start}
  .grid .wide{grid-column:span 2}
  .env{position:relative;background:transparent;aspect-ratio:2.2/1}
  .env>canvas{position:absolute;inset:0;width:100%;height:100%;display:block}
  .ui-label{margin-top:8px;color:#aeb6c6;font-weight:600;font-size:12px;text-align:center}
  .rail{display:grid;grid-template-columns:repeat(4,minmax(180px,1fr));gap:12px}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <h1>Liquid Mirror</h1>
    <p class="lede">Flat center mirrors exactly; rim bends with environment. Focus mapping allocates most of the camera to near-normal view for a truer “mirror”.</p>

    <div class="controls">
      <div class="row cols-2">
        <label>Projection
          <select id="projection">
            <option value="rect">Rectilinear</option>
            <option value="equirect">Equirectangular</option>
          </select>
        </label>
        <label>HFOV
          <input id="hfov" type="range" min="40" max="180" step="1" value="100"><div class="chip" id="hfovVal">100°</div>
        </label>
      </div>

      <div class="row cols-3">
        <label>Corner radius
          <input id="corner" type="range" min="0.00" max="0.45" step="0.01" value="0.22"><div class="chip" id="cornerVal">0.22</div>
        </label>
        <label>Rim width
          <input id="edgeW" type="range" min="0.02" max="0.24" step="0.005" value="0.08"><div class="chip" id="edgeWVal">0.08</div>
        </label>
        <label>Rim bend amp
          <input id="edgeAmp" type="range" min="0.00" max="1.20" step="0.01" value="0.28"><div class="chip" id="edgeAmpVal">0.28</div>
        </label>
      </div>

      <div class="row cols-3">
        <label>Rim hardness
          <input id="edgeHard" type="range" min="0.50" max="3.00" step="0.05" value="1.15"><div class="chip" id="edgeHardVal">1.15</div>
        </label>
        <label>Rim mapping (env in rim)
          <input id="rimMix" type="range" min="0.00" max="1.00" step="0.01" value="1.00"><div class="chip" id="rimMixVal">1.00</div>
        </label>
        <label>Corner AA (px)
          <input id="aa" type="range" min="0.5" max="3.0" step="0.1" value="1.4"><div class="chip" id="aaVal">1.4</div>
        </label>
      </div>

      <div class="row cols-3">
        <label>Focus H (°)
          <input id="focusDH" type="range" min="0" max="30" step="1" value="10"><div class="chip" id="focusDHVal">10°</div>
        </label>
        <label>Fill H (% of image)
          <input id="focusFH" type="range" min="50" max="95" step="1" value="80"><div class="chip" id="focusFHVal">80%</div>
        </label>
        <label>Focus V (°)
          <input id="focusDV" type="range" min="0" max="30" step="1" value="8"><div class="chip" id="focusDVVal">8°</div>
        </label>
      </div>

      <div class="row cols-3">
        <label>Fill V (% of image)
          <input id="focusFV" type="range" min="50" max="95" step="1" value="75"><div class="chip" id="focusFVVal">75%</div>
        </label>
        <label>Exposure
          <input id="exposure" type="range" min="0.70" max="2.20" step="0.05" value="1.10"><div class="chip" id="expVal">1.10</div>
        </label>
        <label>Highlight boost
          <input id="hiboost" type="range" min="0.00" max="1.20" step="0.02" value="0.32"><div class="chip" id="hiboostVal">0.32</div>
        </label>
      </div>

      <div class="row cols-3">
        <label>Hi threshold
          <input id="hithresh" type="range" min="0.40" max="0.90" step="0.02" value="0.60"><div class="chip" id="hithreshVal">0.60</div>
        </label>
        <label>Sharpen
          <input id="sharpen" type="range" min="0.00" max="1.20" step="0.02" value="0.38"><div class="chip" id="sharpVal">0.38</div>
        </label>
        <label>Blur
          <input id="blur" type="range" min="0.00" max="2.50" step="0.05" value="0.70"><div class="chip" id="blurVal">0.70</div>
        </label>
      </div>

      <div class="row cols-3">
        <label>Glow
          <input id="glow" type="range" min="0.00" max="2.00" step="0.05" value="0.28"><div class="chip" id="glowVal">0.28</div>
        </label>
        <label>Glow thresh
          <input id="glowT" type="range" min="0.40" max="0.95" step="0.01" value="0.62"><div class="chip" id="glowTVal">0.62</div>
        </label>
        <label>Blend mode
          <select id="blend"><option value="screen">Screen</option><option value="overlay">Overlay</option><option value="soft">Soft Light</option><option value="mix">Linear Mix</option></select>
        </label>
      </div>

      <div class="row cols-3">
        <label>Env mix
          <input id="envMix" type="range" min="0.00" max="1.00" step="0.01" value="0.46"><div class="chip" id="envMixVal">0.46</div>
        </label>
        <label>Cam zoom
          <input id="camZoom" type="range" min="1.00" max="1.90" step="0.01" value="1.15"><div class="chip" id="zoomVal">1.15×</div>
        </label>
        <label>UV margin
          <input id="uvMargin" type="range" min="0.00" max="0.10" step="0.002" value="0.04"><div class="chip" id="uvMarginVal">0.040</div>
        </label>
      </div>

      <div class="row cols-2">
        <button class="btn" id="flip">Flip webcam</button>
        <button class="btn" id="reset">Reset</button>
      </div>
    </div>
  </div>

  <div>
    <div class="rail">
      <div><div class="env" data-stage="0"></div><div class="ui-label">A — Raw mirror (direct video)</div></div>
      <div><div class="env" data-stage="1"></div><div class="ui-label">B — Post only</div></div>
      <div><div class="env" data-stage="2"></div><div class="ui-label">C — Material (flat)</div></div>
      <div><div class="env" data-stage="3" data-shape="roundrect" style="aspect-ratio:2.2/1"></div><div class="ui-label">D — Full (flat center + rim)</div></div>
    </div>

    <div class="grid" style="margin-top:16px">
      <div class="env wide" data-stage="3" data-shape="roundrect"></div>
      <div class="ui-label">Large rounded-rect (center mirrors; rim bends + reflects env)</div>
    </div>
  </div>
</div>

<script>
(function(){
  "use strict";
  if(!window.EnvMirror) window.EnvMirror = {};
  /* Camera */
  if(!window.EnvMirror.Camera){
    const CS={stream:null,video:null,ready:false,flip:true};
    async function ensureCamera(){
      if(CS.ready && CS.video && !CS.video.paused) return CS;
      const stream=await navigator.mediaDevices.getUserMedia({video:{facingMode:"user"},audio:false});
      const v=document.createElement("video");
      v.autoplay=true; v.playsInline=true; v.muted=true; v.srcObject=stream; await v.play();
      CS.stream=stream; CS.video=v; CS.ready=true; return CS;
    }
    window.EnvMirror.Camera={ensure:ensureCamera,state:CS};
  }
  const Camera=window.EnvMirror.Camera;

  /* GL */
  if(!window.EnvMirror.makeGL){
    window.EnvMirror.makeGL=function(canvas){
      const gl=canvas.getContext("webgl",{alpha:true,antialias:true,premultipliedAlpha:true});
      if(!gl) throw new Error("WebGL not available");
      function compile(type,src){const s=gl.createShader(type); gl.shaderSource(s,src); gl.compileShader(s);
        if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){const info=gl.getShaderInfoLog(s)||"compile error";
          console.error("Shader compile error:\n",info,"\nSource:\n",src); throw new Error(info);} return s; }
      const vsSrc=[
        "attribute vec2 aPos;",
        "varying vec2 vUv;",
        "void main(){ vUv=aPos*0.5+0.5; gl_Position=vec4(aPos,0.,1.); }"
      ].join("\n");

      const fsSrc=[
        "precision mediump float;",
        "varying vec2 vUv;",
        "uniform sampler2D uCam; uniform vec2 uCamSize; uniform vec2 uRes;",
        "uniform float uHFov, uVFov, uFlip, uProjection, uCamZoom, uUVMargin;",
        "uniform float uRound, uStage;",
        "uniform float uRimMix, uCorner, uCornerExp, uEdgeAmp, uEdgeWidth, uEdgeHard;",
        "uniform vec3  uBaseColor; uniform float uEnvMix, uExposure, uSaturation;",
        "uniform float uBlur, uSharpen, uGlow, uGlowT, uBlendMode, uHiBoost, uHiThresh, uAA;",
        "uniform float uFocusDegH, uFocusFillH, uFocusDegV, uFocusFillV;",
        "uniform float uAngSplit0, uAngSplit1;",  // NEW: angle blend degrees
        "",
        "float luma(vec3 c){ return dot(c, vec3(0.2126,0.7152,0.0722)); }",
        "vec3 applyExposure(vec3 c,float e){ return 1.0 - exp(-c*e); }",
        "vec3 applySaturation(vec3 c,float s){ float L=luma(c); return mix(vec3(L),c,s); }",
        "vec3 screen(vec3 b,vec3 s){ return 1.0-(1.0-b)*(1.0-s); }",
        "vec3 overlay(vec3 b,vec3 s){ vec3 lt=step(b,vec3(0.5)); return lt*(2.0*b*s)+(1.0-lt)*(1.0-2.0*(1.0-b)*(1.0-s)); }",
        "vec3 soft(vec3 b,vec3 s){ return mix(b*(1.0-2.0*(1.0-s))+(2.0*s-1.0)*(sqrt(b)-b), 2.0*b*s+b*b*(1.0-2.0*s), step(0.5,s)); }",
        "vec3 blur9(vec2 uv,float r){ if(r<=0.01) return texture2D(uCam,uv).rgb; vec2 t=1.0/uCamSize, R=r*t; vec3 c=vec3(0.0);",
        "  c+=texture2D(uCam,uv).rgb*0.227;",
        "  c+=texture2D(uCam,uv+vec2( R.x,0)).rgb*0.195; c+=texture2D(uCam,uv-vec2( R.x,0)).rgb*0.195;",
        "  c+=texture2D(uCam,uv+vec2(0, R.y)).rgb*0.195; c+=texture2D(uCam,uv-vec2(0, R.y)).rgb*0.195;",
        "  c+=texture2D(uCam,uv+vec2( R.x, R.y)).rgb*0.122; c+=texture2D(uCam,uv+vec2(-R.x, R.y)).rgb*0.122;",
        "  c+=texture2D(uCam,uv+vec2( R.x,-R.y)).rgb*0.122; c+=texture2D(uCam,uv+vec2(-R.x,-R.y)).rgb*0.122; return c; }",
        "",
        "vec2 uvDirect(vec2 uv){ vec2 p=(uv-0.5)/max(uCamZoom,1.0)+0.5; if(uFlip>0.5) p.x=1.0-p.x; p=clamp(p, vec2(uUVMargin), vec2(1.0-uUVMargin)); return p; }",
        "float mapSplit(float a, float a0, float halfRange, float fill){",
        "  float leftEnd = 0.5 - 0.5*fill; float rightStart = 0.5 + 0.5*fill;",
        "  if(a<=-a0){ float t=(a+halfRange)/max(halfRange-a0,1e-6); return mix(0.0, leftEnd, clamp(t,0.0,1.0)); }",
        "  if(a>= a0){ float t=(a-a0)/max(halfRange-a0,1e-6); return mix(rightStart, 1.0, clamp(t,0.0,1.0)); }",
        "  float t=(a+a0)/max(2.0*a0,1e-6); return mix(leftEnd, rightStart, t); }",
        "vec2 uvEnvSplit(vec3 R){",
        "  float PI=3.141592653589793; R=normalize(R); R.z=max(R.z,1e-3);",
        "  float phi=atan(R.x,R.z); float theta=asin(clamp(R.y,-1.0,1.0));",
        "  float hHalf=(uProjection<0.5? uHFov*0.5 : PI*0.5);",
        "  float vHalf=(uProjection<0.5? uVFov*0.5 : PI*0.5);",
        "  float a0H=radians(uFocusDegH); float fillH=clamp(uFocusFillH,0.5,0.99);",
        "  float a0V=radians(uFocusDegV); float fillV=clamp(uFocusFillV,0.5,0.99);",
        "  float u=mapSplit(phi,   max(1e-5,a0H), hHalf, fillH);",
        "  float v=1.0 - mapSplit(theta, max(1e-5,a0V), vHalf, fillV);",
        "  if(uFlip>0.5) u=1.0-u;",
        "  vec2 p=(vec2(u,v)-0.5)/max(uCamZoom,1.0)+0.5; p=clamp(p, vec2(uUVMargin), vec2(1.0-uUVMargin)); return p; }",
        "",
        "// Superellipse rounded-rect SDF (n=2 -> classic, n>2 -> squircle corners)",
        "float sdSuperRoundRect(vec2 p, vec2 b, float r, float n){",
        "  vec2 ap = abs(p); vec2 k = b - vec2(r); vec2 q = ap - k; vec2 qp = max(q, 0.0);",
        "  float outside = pow(pow(qp.x, n) + pow(qp.y, n), 1.0/n) - r;",
        "  float inside = min(max(q.x, q.y), 0.0);",
        "  return outside + inside;",
        "}",
        "float heightRim(vec2 p, vec2 b, float r, float n, float edgeW, float amp, float hard){",
        "  float sd=sdSuperRoundRect(p,b,r,n); if(sd>=0.0) return 0.0;",
        "  float di=clamp(-sd,0.0,edgeW); float s=1.0 - di/edgeW;",
        "  // quintic smooth for zero slope at both ends",
        "  float ss = s*s*s*(10.0 - 15.0*s + 6.0*s*s);",
        "  return amp*pow(ss,hard);",
        "}",
        "float alphaAA(vec2 p, vec2 b, float r, float n){",
        "  float px=uAA/max(min(uRes.x,uRes.y),1.0); vec2 o = vec2(0.5, -0.5)*px;",
        "  float a0=smoothstep(px, -px, sdSuperRoundRect(p, b, r, n));",
        "  float a1=smoothstep(px, -px, sdSuperRoundRect(p+o.xy, b, r, n));",
        "  float a2=smoothstep(px, -px, sdSuperRoundRect(p+o.yx, b, r, n));",
        "  float a3=smoothstep(px, -px, sdSuperRoundRect(p-o.xy, b, r, n));",
        "  return 0.25*(a0+a1+a2+a3);",
        "}",
        "",
        "void main(){",
        "  float aspect=uRes.x/max(uRes.y,1.0); vec2 p=(vUv-0.5)*vec2(aspect,1.0); vec2 b=vec2(aspect*0.5, 0.5);",
        "  float corner=clamp(uCorner,0.0,0.49); float n=max(1.8,uCornerExp);",
        "  float alpha=alphaAA(p,b,corner,n);",
        "",
        "  if(uStage<0.5){ vec3 col=texture2D(uCam, uvDirect(vUv)).rgb; gl_FragColor=vec4(col,1.0); return; }",
        "",
        "  vec2 uvD = uvDirect(vUv);",
        "  vec3 sampleDirect=texture2D(uCam, uvD).rgb;",
        "  vec3 postB = blur9(uvD, uBlur);",
        "  vec3 postS = blur9(uvD, max(0.5, uBlur*0.6));",
        "  vec3 postSharpen = clamp(sampleDirect + uSharpen*(sampleDirect - postS), 0.0, 1.0);",
        "  vec3 postCol = mix(postSharpen, postB, smoothstep(0.0,1.2,uBlur));",
        "  postCol = applyExposure(postCol, uExposure); postCol = applySaturation(postCol, uSaturation);",
        "  float L=luma(postCol); float hi=smoothstep(uHiThresh,1.0,L)*uHiBoost; postCol *= (1.0+hi);",
        "  if(uStage<1.5){ gl_FragColor=vec4(clamp(postCol,0.0,1.0),1.0); return; }",
        "",
        "  float e=1.0/max(uRes.x,uRes.y);",
        "  float z = (uStage>2.5)? heightRim(p,b,corner,n,uEdgeWidth,uEdgeAmp,uEdgeHard) : 0.0;",
        "  float zx1=heightRim(p+vec2(e,0.0),b,corner,n,uEdgeWidth,uEdgeAmp,uEdgeHard);",
        "  float zx0=heightRim(p-vec2(e,0.0),b,corner,n,uEdgeWidth,uEdgeAmp,uEdgeHard);",
        "  float zy1=heightRim(p+vec2(0.0,e),b,corner,n,uEdgeWidth,uEdgeAmp,uEdgeHard);",
        "  float zy0=heightRim(p-vec2(0.0,e),b,corner,n,uEdgeWidth,uEdgeAmp,uEdgeHard);",
        "  vec2 grad= (uStage>2.5)? 0.5*vec2(zx1-zx0,zy1-zy0)/e : vec2(0.0);",
        "  vec3 N=normalize(vec3(-grad,1.0)); N=normalize(mix(vec3(0,0,1), N, uRound));",
        "  vec3 V=vec3(0,0,1); vec3 R=reflect(-V,N); R.z=max(R.z,1e-3);",
        "",
        "float sd = sdSuperRoundRect(p,b,corner,n);",
        "// 1 at edge, 0 inside (smooth)",
        "float rimT = smoothstep(uEdgeWidth, 0.0, max(-sd, 0.0));",
        "float envW_rim = (uStage>2.5)? (uRimMix*rimT) : 0.0;",
        "",
        "  // NEW: angle-based center mapping — 0° uses full video, ramps to env by uAngSplit1",
        "  float ang = acos(clamp(dot(N,V), 0.0, 1.0));",
        "  float wAng = smoothstep(radians(uAngSplit0), radians(uAngSplit1), ang);",
        "  float envW = max(envW_rim, wAng);",
        "",
        "  vec2 uvE = uvEnvSplit(R);",
        "  vec2 uv  = mix(uvDirect(vUv), uvE, envW);",
        "  vec3 envRaw = texture2D(uCam, uv).rgb;",
        "  vec3 envB   = blur9(uv, uBlur);",
        "  vec3 envS   = blur9(uv, max(0.5,uBlur*0.6));",
        "  vec3 envSharp = clamp(envRaw + uSharpen*(envRaw - envS), 0.0, 1.0);",
        "  vec3 env = mix(envSharp, envB, smoothstep(0.0,1.2,uBlur));",
        "  env = applyExposure(env, uExposure); env = applySaturation(env, uSaturation);",
        "  float L2=luma(env); float hi2=smoothstep(uHiThresh,1.0,L2)*uHiBoost; env *= (1.0+hi2);",
        "",
        "  float NdV=clamp(dot(N,V),0.0,1.0); float F0=0.90; float F=F0 + (1.0-F0)*pow(1.0-NdV,5.0);",
        "  vec3 base=uBaseColor; vec3 refl = env*(uEnvMix*F); vec3 col;",
        "  if(uBlendMode<0.5)      col = mix(base, base+refl, uEnvMix);",
        "  else if(uBlendMode<1.5) col = screen(base, refl);",
        "  else if(uBlendMode<2.5) col = overlay(base, refl);",
        "  else                    col = soft(base, refl);",
        "",
        "  float bright=max(max(env.r,env.g),env.b);",
        "  float gMask=max(0.0, bright-uGlowT)+pow(1.0-NdV,4.0)*0.2; col+= blur9(uv,2.5)*gMask*uGlow;",
        "  col=clamp(col,0.0,1.0);",
        "  if(uStage<2.5){ gl_FragColor=vec4(col,1.0); return; }",
        "  gl_FragColor=vec4(col,alpha);",
        "}"
      ].join("\n");

      const vs=compile(gl.VERTEX_SHADER,vsSrc);
      const fs=compile(gl.FRAGMENT_SHADER,fsSrc);
      const prog=gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
      if(!gl.getProgramParameter(prog,gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
      gl.useProgram(prog); gl.enable(gl.BLEND); gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA); gl.clearColor(0,0,0,0);

      const quad=gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER,quad);
      gl.bufferData(gl.ARRAY_BUFFER,new Float32Array([-1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1]),gl.STATIC_DRAW);
      const aPos=gl.getAttribLocation(prog,"aPos"); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

      const tex=gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D,tex);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);

      function U(n){ return gl.getUniformLocation(prog,n); }
      const uniforms={
        uCam:U('uCam'),uCamSize:U('uCamSize'),uRes:U('uRes'),
        uHFov:U('uHFov'),uVFov:U('uVFov'),uFlip:U('uFlip'),uProjection:U('uProjection'),
        uCamZoom:U('uCamZoom'),uUVMargin:U('uUVMargin'),
        uRound:U('uRound'),uStage:U('uStage'),
        uRimMix:U('uRimMix'),uCorner:U('uCorner'),uCornerExp:U('uCornerExp'),
        uEdgeAmp:U('uEdgeAmp'),uEdgeWidth:U('uEdgeWidth'),uEdgeHard:U('uEdgeHard'),
        uBaseColor:U('uBaseColor'),uEnvMix:U('uEnvMix'),uExposure:U('uExposure'),uSaturation:U('uSaturation'),
        uBlur:U('uBlur'),uSharpen:U('uSharpen'),uGlow:U('uGlow'),uGlowT:U('uGlowT'),
        uBlendMode:U('uBlendMode'),uHiBoost:U('uHiBoost'),uHiThresh:U('uHiThresh'),uAA:U('uAA'),
        uFocusDegH:U('uFocusDegH'),uFocusFillH:U('uFocusFillH'),uFocusDegV:U('uFocusDegV'),uFocusFillV:U('uFocusFillV'),
        uAngSplit0:U('uAngSplit0'),uAngSplit1:U('uAngSplit1')
      };
      return {gl,prog,tex,uniforms};
    };
  }
  const makeGL=window.EnvMirror.makeGL;

  /* Engine */
  if(!window.EnvButtons){
    window.EnvButtons=(function(){
      const instances=new Map();
      function hfovToVfov(hfov,aspect){return 2*Math.atan(Math.tan(hfov/2)/aspect);}
      function blendCode(s){return s==='screen'?1.0:(s==='overlay'?2.0:(s==='soft'?3.0:0.0));}
      function create(host,opts){
        const stage=parseInt(host.getAttribute('data-stage')||'3',10);
        const options=Object.assign({
          hfovDeg:100,projection:'rect',flip:true,
          roundHint:0.70,corner:0.22,cornerExp:3.5, aa:1.4,
          edgeAmp:0.28,edgeWidth:0.08,edgeHard:1.15,rimMix:1.00,
          base:[0.82,0.84,0.87],envMix:0.46,exposure:1.10,saturation:1.0,
          blur:0.70,sharpen:0.38,glow:0.28,glowT:0.62,blend:'screen',
          camZoom:1.15,uvMargin:0.04, hiBoost:0.32, hiThresh:0.60,
          focusDegH:10, focusFillH:0.80, focusDegV:8, focusFillV:0.75,
          angSplit0:0.0, angSplit1:10.0  // NEW defaults: 0°–10° stays video
        },opts||{});

        let canvas=host.querySelector('canvas'); if(!canvas){canvas=document.createElement('canvas');host.appendChild(canvas);}
        const glx=makeGL(canvas), gl=glx.gl;
        const dpr=Math.max(1,window.devicePixelRatio||1);
        function resize(){const r=host.getBoundingClientRect(); const W=Math.max(1,(r.width*dpr)|0), H=Math.max(1,(r.height*dpr)|0);
          if(canvas.width!==W||canvas.height!==H){canvas.width=W;canvas.height=H;gl.viewport(0,0,W,H);} }
        const ro=new ResizeObserver(resize); ro.observe(host); resize();

        const t0=performance.now();
        function frame(){
          const v=Camera.state.video; if(!v){requestAnimationFrame(frame);return;}
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D,glx.tex);
          try{gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,v);}catch(e){}
          const r=host.getBoundingClientRect();
          const hf=options.hfovDeg*Math.PI/180, vf=hfovToVfov(hf,(v.videoWidth||16)/(v.videoHeight||9));

          gl.uniform2f(glx.uniforms.uRes,r.width,r.height);
          gl.uniform1i(glx.uniforms.uCam,0);
          gl.uniform2f(glx.uniforms.uCamSize,v.videoWidth||640,v.videoHeight||480);
          gl.uniform1f(glx.uniforms.uHFov,hf); gl.uniform1f(glx.uniforms.uVFov,vf);
          gl.uniform1f(glx.uniforms.uFlip,options.flip?1.0:0.0);
          gl.uniform1f(glx.uniforms.uProjection, options.projection==='rect'?0.0:1.0);
          gl.uniform1f(glx.uniforms.uCamZoom, options.camZoom);
          gl.uniform1f(glx.uniforms.uUVMargin, options.uvMargin);

          gl.uniform1f(glx.uniforms.uRound, options.roundHint);
          gl.uniform1f(glx.uniforms.uStage, stage);
          gl.uniform1f(glx.uniforms.uRimMix, options.rimMix);
          gl.uniform1f(glx.uniforms.uCorner, options.corner);
          gl.uniform1f(glx.uniforms.uCornerExp, options.cornerExp);
          gl.uniform1f(glx.uniforms.uEdgeAmp, options.edgeAmp);
          gl.uniform1f(glx.uniforms.uEdgeWidth, options.edgeWidth);
          gl.uniform1f(glx.uniforms.uEdgeHard, options.edgeHard);
          gl.uniform1f(glx.uniforms.uAA, options.aa);

          gl.uniform3f(glx.uniforms.uBaseColor, options.base[0],options.base[1],options.base[2]);
          gl.uniform1f(glx.uniforms.uEnvMix, options.envMix);
          gl.uniform1f(glx.uniforms.uExposure, options.exposure);
          gl.uniform1f(glx.uniforms.uSaturation, options.saturation);
          gl.uniform1f(glx.uniforms.uBlur, options.blur);
          gl.uniform1f(glx.uniforms.uSharpen, options.sharpen);
          gl.uniform1f(glx.uniforms.uGlow, options.glow);
          gl.uniform1f(glx.uniforms.uGlowT, options.glowT);
          gl.uniform1f(glx.uniforms.uBlendMode, blendCode(options.blend));
          gl.uniform1f(glx.uniforms.uHiBoost, options.hiBoost);
          gl.uniform1f(glx.uniforms.uHiThresh, options.hiThresh);

          gl.uniform1f(glx.uniforms.uFocusDegH, options.focusDegH);
          gl.uniform1f(glx.uniforms.uFocusFillH, options.focusFillH);
          gl.uniform1f(glx.uniforms.uFocusDegV, options.focusDegV);
          gl.uniform1f(glx.uniforms.uFocusFillV, options.focusFillV);

          gl.uniform1f(glx.uniforms.uAngSplit0, options.angSplit0);
          gl.uniform1f(glx.uniforms.uAngSplit1, options.angSplit1);

          gl.drawArrays(gl.TRIANGLES,0,6);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);
        instances.set(host,{host,canvas,glx,options,stage});
        return instances.get(host);
      }

      async function applyTo(selector,options){
        await Camera.ensure();
        document.querySelectorAll(selector||'.env').forEach(el=>{
          if(!el.__env){ el.__env=create(el, options); }
        });
      }
      function setAllOptions(p){ instances.forEach(inst=>Object.assign(inst.options,p||{})); }
      return {applyTo,instances,setAllOptions};
    })();
  }

  /* UI wiring: add two sliders if you want them visible */
  document.addEventListener('DOMContentLoaded', async ()=>{
    await window.EnvButtons.applyTo('.env', {});

    const $ = id => document.getElementById(id);

    // Generic binder: attaches 'input' listener, updates chip, pushes uniform(s)
    function bind(id, chip, key, { fmt, scale=1 } = {}){
      const el = $(id); if(!el) return;
      const render = v => {
        if(!chip) return;
        const t = fmt ? fmt(v) :
                  (typeof v === 'number' ? v.toFixed(2) : String(v));
        $(chip).textContent = t;
      };
      const push = v => {
        const p = {};
        p[key] = (typeof v === 'number') ? v * scale : v;
        window.EnvButtons.setAllOptions(p);
      };
      const oninput = () => {
        let v = el.type === 'range' ? +el.value : el.value;
        render(v); push(v);
      };
      el.addEventListener('input', oninput);
      oninput(); // fire once
    }

    // Degree / percent helpers
    const deg  = v => `${(v|0)}°`;
    const pct  = v => `${(v|0)}%`;
    const zoom = v => `${(+v).toFixed(2)}×`;

    // Attach ALL controls
    bind('hfov',     'hfovVal',     'hfovDeg',     { fmt:deg });
    bind('corner',   'cornerVal',   'corner');
    bind('edgeW',    'edgeWVal',    'edgeWidth');
    bind('edgeAmp',  'edgeAmpVal',  'edgeAmp');
    bind('edgeHard', 'edgeHardVal', 'edgeHard');
    bind('rimMix',   'rimMixVal',   'rimMix');
    bind('aa',       'aaVal',       'aa',          { fmt:v=>v.toFixed(1) });

    bind('focusDH',  'focusDHVal',  'focusDegH',   { fmt:deg });
    bind('focusFH',  'focusFHVal',  'focusFillH',  { fmt:pct, scale:0.01 });
    bind('focusDV',  'focusDVVal',  'focusDegV',   { fmt:deg });
    bind('focusFV',  'focusFVVal',  'focusFillV',  { fmt:pct, scale:0.01 });

    bind('exposure', 'expVal',      'exposure');
    bind('hiboost',  'hiboostVal',  'hiBoost');
    bind('hithresh', 'hithreshVal', 'hiThresh');
    bind('sharpen',  'sharpVal',    'sharpen');
    bind('blur',     'blurVal',     'blur');
    bind('glow',     'glowVal',     'glow');
    bind('glowT',    'glowTVal',    'glowT');

    bind('envMix',   'envMixVal',   'envMix');
    bind('camZoom',  'zoomVal',     'camZoom',     { fmt:zoom });
    bind('uvMargin', 'uvMarginVal', 'uvMargin',    { fmt:v=>(+v).toFixed(3) });

    // Optional (only if you add these 3 inputs to your panel):
    // bind('cornerExp','cornerExpVal','cornerExp');
    // bind('ang0',     'ang0Val',     'angSplit0',  { fmt:deg });
    // bind('ang1',     'ang1Val',     'angSplit1',  { fmt:deg });

    const projection = $('projection');
    if (projection) projection.addEventListener('change', () =>
      EnvButtons.setAllOptions({ projection: projection.value==='equirect'?'equirect':'rect' })
    );

    const blend = $('blend');
    if (blend) blend.addEventListener('change', () =>
      EnvButtons.setAllOptions({ blend: blend.value })
    );

    const flip = $('flip');
    if (flip) flip.addEventListener('click', () =>
      EnvButtons.instances.forEach(i => i.options.flip = !i.options.flip)
    );

    const reset = $('reset');
    if (reset) reset.addEventListener('click', () => {
      // quick light reset — tweak as you like
      EnvButtons.setAllOptions({
        exposure:1.10, envMix:0.46, blur:0.70, sharpen:0.38, glow:0.28, glowT:0.62,
        hiBoost:0.32, hiThresh:0.60, camZoom:1.15, uvMargin:0.04,
        focusDegH:10, focusFillH:0.80, focusDegV:8, focusFillV:0.75
      });
    });
  });
})();
</script>

</body>
</html>
