<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Liquid Mirror — Rounded-Rect Rim + Highlight Control</title>
<style>
  :root { --bg:#0e0f12; --card:#16181d; --fg:#e6e9ef; --muted:#9aa3b2; }
  html, body { height:100%; }
  body {
    margin:0; font:14px/1.4 system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
    background:radial-gradient(80% 100% at 50% 0%, #13151a, #0b0c0f 70%); color:var(--fg);
    display:grid; place-items:center; padding:32px;
  }
  .wrap { display:grid; gap:24px; grid-template-columns: minmax(320px,420px) 1fr; width:min(1200px, 94vw); align-items:start; }
  .card { background:var(--card); border:1px solid #23262d; border-radius:16px; padding:16px; box-shadow:0 10px 30px rgba(0,0,0,.25) inset, 0 10px 40px rgba(0,0,0,.4); }
  .controls { display:grid; gap:12px; }
  .row { display:grid; gap:10px; }
  .row.cols-2 { grid-template-columns: 1fr 1fr; }
  .row.cols-3 { grid-template-columns: 1fr 1fr 1fr; }
  label { display:grid; gap:6px; font-weight:600; }
  input[type="range"], select { width:100%; }
  .btn { display:inline-flex; align-items:center; gap:10px; padding:10px 12px; border-radius:10px; border:1px solid #272a31; background:#15171b; color:#e6ebf3; cursor:pointer; }
  .btn:hover { background:#1a1d22; }
  .chip{ background:#111317; padding:6px 10px; border-radius:10px; border:1px solid #2a2f37; color:#aeb6c6; }

  /* GL tiles */
  .env-ui { position:relative; overflow:visible; border-radius:0; background:transparent; aspect-ratio: 2.2/1; }
  .env-ui > canvas { position:absolute; inset:0; width:100%; height:100%; display:block; }
  .ui-label { margin-top:8px; color:#aeb6c6; font-weight:600; font-size:12px; text-align:center; }

  .grid { display:grid; grid-template-columns:repeat(2, minmax(240px, 1fr)); gap:18px; align-items:start; }
  .grid .wide { grid-column: span 2; }
</style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h2 style="margin:4px 0 8px;">Rounded-Rect Rim + Highlight-biased Silver</h2>
      <p class="muted">Border = rim. Outside is transparent. Slightly dimmer mids, boosted highlights, and true rounded-rect geometry.</p>

      <div class="controls">
        <div class="row cols-2">
          <label>Projection
            <select id="projection">
              <option value="rect">Rectilinear</option>
              <option value="equirect">Equirectangular</option>
            </select>
          </label>
          <label>HFOV
            <input id="hfov" type="range" min="40" max="180" step="1" value="100">
            <div class="chip" id="hfovVal">100°</div>
          </label>
        </div>

        <div class="row cols-3">
          <label>Corner radius
            <input id="corner" type="range" min="0.00" max="0.45" step="0.01" value="0.22">
            <div class="chip" id="cornerVal">0.22</div>
          </label>
          <label>Rim width
            <input id="edgeW" type="range" min="0.02" max="0.18" step="0.005" value="0.08">
            <div class="chip" id="edgeWVal">0.08</div>
          </label>
          <label>Rim amp
            <input id="edgeAmp" type="range" min="0.00" max="1.00" step="0.01" value="0.30">
            <div class="chip" id="edgeAmpVal">0.30</div>
          </label>
        </div>

        <div class="row cols-3">
          <label>Highlight boost
            <input id="hiboost" type="range" min="0.00" max="1.20" step="0.02" value="0.40">
            <div class="chip" id="hiboostVal">0.40</div>
          </label>
          <label>Hi threshold
            <input id="hithresh" type="range" min="0.40" max="0.90" step="0.02" value="0.62">
            <div class="chip" id="hithreshVal">0.62</div>
          </label>
          <label>Env mix
            <input id="envMix" type="range" min="0.00" max="1.00" step="0.01" value="0.48">
            <div class="chip" id="envMixVal">0.48</div>
          </label>
        </div>

        <div class="row cols-3">
          <label>Exposure
            <input id="exposure" type="range" min="0.60" max="2.50" step="0.05" value="1.35">
            <div class="chip" id="expVal">1.35</div>
          </label>
          <label>Sharpen
            <input id="sharpen" type="range" min="0.00" max="1.20" step="0.02" value="0.50">
            <div class="chip" id="sharpVal">0.50</div>
          </label>
          <label>Glow
            <input id="glow" type="range" min="0.00" max="2.00" step="0.05" value="0.40">
            <div class="chip" id="glowVal">0.40</div>
          </label>
        </div>

        <div class="row cols-3">
          <label>Cam Zoom
            <input id="camZoom" type="range" min="1.00" max="1.60" step="0.01" value="1.18">
            <div class="chip" id="zoomVal">1.18×</div>
          </label>
          <label>Blend
            <select id="blend">
              <option value="screen">Screen (bright)</option>
              <option value="overlay">Overlay</option>
              <option value="soft">Soft Light</option>
              <option value="mix">Linear Mix</option>
            </select>
          </label>
          <button class="btn" id="flip">Flip webcam</button>
        </div>
      </div>
    </div>

    <div class="grid">
      <!-- NEW: true rounded-rect rim (border == rim) -->
      <div>
        <div class="env-ui wide" data-shape="roundrect" data-corner="0.22" data-base="#d1d5db"></div>
        <div class="ui-label">Rounded-rect with beveled rim (border == rim)</div>
      </div>

      <!-- Existing shapes still work -->
      <div>
        <div class="env-ui" data-shape="pill" data-base="#d2d6db" style="aspect-ratio: 2.7/1;"></div>
        <div class="ui-label">Pill</div>
      </div>
      <div>
        <div class="env-ui" data-shape="squircle" data-base="#cbd0d6" style="aspect-ratio:1.4/1;"></div>
        <div class="ui-label">Squircle</div>
      </div>
      <div>
        <div class="env-ui" data-shape="flat" data-base="#d9dce1" style="aspect-ratio:2.2/1;"></div>
        <div class="ui-label">Flat material reference</div>
      </div>
    </div>
  </div>

<script>
(function(){
  "use strict";
  if (!window.EnvMirror) window.EnvMirror = {};

  /* Camera */
  if (!window.EnvMirror.Camera) {
    const CS = { stream:null, video:null, ready:false, flip:true };
    async function ensureCamera(){
      if (CS.ready && CS.video && !CS.video.paused) return CS;
      const stream = await navigator.mediaDevices.getUserMedia({ video:{ facingMode:"user" }, audio:false });
      const v = document.createElement("video");
      v.autoplay = true; v.playsInline = true; v.muted = true; v.srcObject = stream; await v.play();
      CS.stream = stream; CS.video = v; CS.ready = true; return CS;
    }
    window.EnvMirror.Camera = { ensure: ensureCamera, state: CS };
  }
  const Camera = window.EnvMirror.Camera;

  /* WebGL */
  if (!window.EnvMirror.makeGL) {
    window.EnvMirror.makeGL = function(canvas){
      const gl = canvas.getContext("webgl", { alpha:true, antialias:true, premultipliedAlpha:true });
      if(!gl) throw new Error("WebGL not available");

      function compile(type, src){
        const s = gl.createShader(type); gl.shaderSource(s, src); gl.compileShader(s);
        if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){
          const info = gl.getShaderInfoLog(s)||"compile error";
          console.error("Shader compile error:\n", info, "\nSource:\n", src);
          throw new Error(info);
        }
        return s;
      }

      const vsSrc = [
        "attribute vec2 aPos;",
        "varying vec2 vUv;",
        "void main(){ vUv = aPos*0.5 + 0.5; gl_Position = vec4(aPos,0.,1.); }"
      ].join("\n");

      const fsSrc = [
        "precision mediump float;",
        "varying vec2 vUv;",
        "uniform sampler2D uCam; uniform vec2 uCamSize; uniform vec2 uRes;",
        "uniform float uTime; uniform float uHFov; uniform float uVFov; uniform float uFlip;",
        "uniform float uProjection; uniform float uCamZoom; uniform float uUVMargin;",
        "uniform float uRipple; uniform float uRound;",
        "uniform float uShape; // 0 dome,2 pill,4 squircle,5 concave,6 flat, 7 roundrectRim",
        "uniform float uCorner; // rounded-rect corner radius in normalized space (0..0.5)",
        "uniform float uEdgeAmp; uniform float uEdgeWidth;",
        "uniform vec3  uBaseColor; uniform float uEnvMix; uniform float uExposure; uniform float uSaturation;",
        "uniform float uBlur; uniform float uSharpen; uniform float uGlow; uniform float uGlowT;",
        "uniform float uBlendMode; // 0 mix,1 screen,2 overlay,3 soft",
        "uniform float uHiBoost; uniform float uHiThresh; // highlight bias",
        "",
        "float luma(vec3 c){ return dot(c, vec3(0.2126,0.7152,0.0722)); }",
        "vec3 applyExposure(vec3 c, float e){ return 1.0 - exp(-c*e); }",
        "vec3 applySaturation(vec3 c, float sat){ float l = luma(c); return mix(vec3(l), c, sat); }",
        "vec3 blendScreen(vec3 b, vec3 s){ return 1.0 - (1.0 - b)*(1.0 - s); }",
        "vec3 blendOverlay(vec3 b, vec3 s){ vec3 lt = step(b, vec3(0.5)); return lt*(2.0*b*s) + (1.0-lt)*(1.0 - 2.0*(1.0-b)*(1.0-s)); }",
        "vec3 blendSoft(vec3 b, vec3 s){ return mix(b*(1.0 - 2.0*(1.0 - s)) + (2.0*s - 1.0)*(sqrt(b) - b), 2.0*b*s + b*b*(1.0 - 2.0*s), step(0.5, s)); }",
        "",
        "vec3 sampleBlur9(vec2 uv, float radius){",
        "  if (radius <= 0.01) return texture2D(uCam, uv).rgb;",
        "  vec2 texel = 1.0 / uCamSize; vec2 r = radius * texel; vec3 c = vec3(0.0);",
        "  c += texture2D(uCam, uv).rgb * 0.2270;",
        "  c += texture2D(uCam, uv + vec2( r.x, 0.0)).rgb * 0.1946;",
        "  c += texture2D(uCam, uv - vec2( r.x, 0.0)).rgb * 0.1946;",
        "  c += texture2D(uCam, uv + vec2( 0.0, r.y)).rgb * 0.1946;",
        "  c += texture2D(uCam, uv - vec2( 0.0, r.y)).rgb * 0.1946;",
        "  c += texture2D(uCam, uv + vec2( r.x, r.y)).rgb * 0.1216;",
        "  c += texture2D(uCam, uv + vec2(-r.x, r.y)).rgb * 0.1216;",
        "  c += texture2D(uCam, uv + vec2( r.x,-r.y)).rgb * 0.1216;",
        "  c += texture2D(uCam, uv + vec2(-r.x,-r.y)).rgb * 0.1216;",
        "  return c;",
        "}",
        "",
        "vec2 camMap(vec3 R){",
        "  float PI = 3.141592653589793;",
        "  R = normalize(R); R.z = max(R.z, 1e-3);",
        "  float phi = atan(R.x, R.z);",
        "  float theta = asin(clamp(R.y, -1.0, 1.0));",
        "  float u = (uProjection < 0.5) ? (0.5 + phi / uHFov) : (0.5 + phi / PI);",
        "  float v = (uProjection < 0.5) ? (0.5 - theta / uVFov) : (0.5 - theta / (0.5*PI));",
        "  if (uFlip > 0.5) u = 1.0 - u;",
        "  // center zoom & margin clamp -> no edge repeats",
        "  float z = max(uCamZoom, 1.0);",
        "  vec2 uv = (vec2(u,v) - 0.5) / z + 0.5;",
        "  uv = clamp(uv, vec2(uUVMargin), vec2(1.0 - uUVMargin));",
        "  return uv;",
        "}",
        "",
        "// --- Signed distance for rounded rectangle (fits the host rect exactly) ---",
        "float sdRoundRect(vec2 p, vec2 b, float r){",
        "  vec2 q = abs(p) - (b - vec2(r));",
        "  return length(max(q,0.0)) + min(max(q.x,q.y), 0.0) - r;",
        "}",
        "",
        "// Height field = gentle cap + linear bevel rim along sd==0 (inside only)",
        "float heightField(vec2 p, vec2 b, float r, out float sd){",
        "  sd = sdRoundRect(p, b, r);",
        "  float di = max(-sd, 0.0);",
        "  // bevel rim: max at edge, linear fade inwards",
        "  float rim = (di < uEdgeWidth) ? (uEdgeAmp * (1.0 - di / uEdgeWidth)) : 0.0;",
        "  // mild interior cap using superellipse radius (n=4) normalized to b",
        "  vec2 q = clamp(abs(p) / b, 0.0, 1.0);",
        "  float rn = pow(pow(q.x,4.0) + pow(q.y,4.0), 0.25);",
        "  float cap = 0.07 * (1.0 - rn);",
        "  return cap + rim;",
        "}",
        "",
        "void main(){",
        "  // aspect-corrected local space: p.x spans [-aspect/2..+aspect/2], p.y [-0.5..+0.5]",
        "  float aspect = uRes.x / max(uRes.y, 1.0);",
        "  vec2 p = (vUv - 0.5) * vec2(aspect, 1.0);",
        "  vec2 b = vec2(aspect*0.5, 0.5);",
        "",
        "  // Choose which boundary to use for alpha/height",
        "  bool useRR = (uShape > 6.5); // roundrect rim mode",
        "  float sd; float z;",
        "  if (useRR){",
        "    z = heightField(p, b, clamp(uCorner, 0.0, 0.49), sd);",
        "  } else {",
        "    // fallback: simple circle/pill/squircle footprint for legacy tiles",
        "    float R = 0.5;",
        "    vec2 pp = p; if (uShape>1.5 && uShape<2.5) pp.x /= 1.8; // pill stretch",
        "    sd = length(pp) - R;",
        "    float di = max(-sd, 0.0);",
        "    float rim = (di < uEdgeWidth) ? (uEdgeAmp * (1.0 - di / uEdgeWidth)) : 0.0;",
        "    float cap = 0.06 * (1.0 - min(length(pp)/R,1.0));",
        "    z = cap + rim;",
        "  }",
        "",
        "  // numerical gradient of z for stable normals",
        "  float e = 0.0015;",
        "  float sdTmp; float zx1 = heightField(p+vec2(e,0.0), b, clamp(uCorner,0.0,0.49), sdTmp);",
        "  float zx0 = heightField(p-vec2(e,0.0), b, clamp(uCorner,0.0,0.49), sdTmp);",
        "  float zy1 = heightField(p+vec2(0.0,e), b, clamp(uCorner,0.0,0.49), sdTmp);",
        "  float zy0 = heightField(p-vec2(0.0,e), b, clamp(uCorner,0.0,0.49), sdTmp);",
        "  vec2 grad = 0.5*vec2(zx1 - zx0, zy1 - zy0)/e;",
        "  vec3 N = normalize(vec3(-grad, 1.0));",
        "  // extra roundness blend and optional ripple",
        "  if (uRipple > 0.001){",
        "    float rp = sin((p.x*20.0 + p.y*18.0) + uTime*0.7)*0.5 + 0.5;",
        "    N.xy += (rp - 0.5) * (uRipple * 0.3);",
        "    N = normalize(N);",
        "  }",
        "  N = normalize(mix(vec3(0.0,0.0,1.0), N, clamp(uRound,0.0,1.0)));",
        "",
        "  // reflection sample",
        "  vec3 V = vec3(0.0,0.0,1.0);",
        "  vec3 R = reflect(-V, N); R.z = max(R.z, 1e-3);",
        "  vec2 camUV = camMap(R);",
        "  vec3 envRaw = texture2D(uCam, camUV).rgb;",
        "  vec3 envB   = sampleBlur9(camUV, uBlur);",
        "  vec3 envS   = sampleBlur9(camUV, max(0.5, uBlur*0.6));",
        "  vec3 envSharp = clamp(envRaw + uSharpen*(envRaw - envS), 0.0, 1.0);",
        "  vec3 env = mix(envSharp, envB, smoothstep(0.0,1.2,uBlur));",
        "  env = applyExposure(env, uExposure);",
        "  env = applySaturation(env, uSaturation);",
        "",
        "  // highlight-only push: boosts brights, leaves mids alone",
        "  float L = luma(env);",
        "  float hi = smoothstep(uHiThresh, 1.0, L) * uHiBoost;",
        "  env *= (1.0 + hi);",
        "",
        "  // metallic fresnel",
        "  float NdV = clamp(dot(N,V), 0.0, 1.0);",
        "  float F0 = 0.90; float F = F0 + (1.0 - F0) * pow(1.0 - NdV, 5.0);",
        "  vec3 base = uBaseColor;",
        "  vec3 refl = env * (uEnvMix * F);",
        "  vec3 col;",
        "  if (uBlendMode < 0.5)      col = mix(base, base + refl, uEnvMix);",
        "  else if (uBlendMode < 1.5) col = blendScreen(base, refl);",
        "  else if (uBlendMode < 2.5) col = blendOverlay(base, refl);",
        "  else                       col = blendSoft(base, refl);",
        "",
        "  // glow (bright pass + Fresnel)",
        "  float bright = max(max(env.r,env.g),env.b);",
        "  float gMask = max(0.0, bright - uGlowT) + pow(1.0 - NdV, 4.0)*0.25;",
        "  vec3 glowCol = sampleBlur9(camUV, 3.0) * gMask * uGlow;",
        "  col += glowCol;",
        "",
        "  // inside mask (anti-aliased); outside fully transparent",
        "  float aa = 1.8 / min(uRes.x, uRes.y);",
        "  float alpha = smoothstep(aa, -aa, sd);",
        "  col = clamp(col, 0.0, 1.0) * alpha; // premultiply",
        "  gl_FragColor = vec4(col, alpha);",
        "}"
      ].join("\n");

      const vs = compile(gl.VERTEX_SHADER, vsSrc);
      const fs = compile(gl.FRAGMENT_SHADER, fsSrc);
      const prog = gl.createProgram(); gl.attachShader(prog,vs); gl.attachShader(prog,fs); gl.linkProgram(prog);
      if(!gl.getProgramParameter(prog, gl.LINK_STATUS)) throw new Error(gl.getProgramInfoLog(prog));
      gl.useProgram(prog);

      // state: premultiplied alpha blending
      gl.enable(gl.BLEND);
      gl.blendFunc(gl.ONE, gl.ONE_MINUS_SRC_ALPHA);
      gl.clearColor(0,0,0,0);

      const quad = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, quad);
      gl.bufferData(gl.ARRAY_BUFFER, new Float32Array([ -1,-1, 1,-1, -1,1,  -1,1, 1,-1, 1,1 ]), gl.STATIC_DRAW);
      const aPos = gl.getAttribLocation(prog,'aPos'); gl.enableVertexAttribArray(aPos); gl.vertexAttribPointer(aPos,2,gl.FLOAT,false,0,0);

      const tex = gl.createTexture(); gl.bindTexture(gl.TEXTURE_2D, tex);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);

      function U(n){ return gl.getUniformLocation(prog, n); }
      const uniforms = {
        uCam:U('uCam'), uCamSize:U('uCamSize'), uRes:U('uRes'), uTime:U('uTime'),
        uHFov:U('uHFov'), uVFov:U('uVFov'), uFlip:U('uFlip'),
        uProjection:U('uProjection'), uCamZoom:U('uCamZoom'), uUVMargin:U('uUVMargin'),
        uRipple:U('uRipple'), uRound:U('uRound'),
        uShape:U('uShape'), uCorner:U('uCorner'), uEdgeAmp:U('uEdgeAmp'), uEdgeWidth:U('uEdgeWidth'),
        uBaseColor:U('uBaseColor'), uEnvMix:U('uEnvMix'), uExposure:U('uExposure'), uSaturation:U('uSaturation'),
        uBlur:U('uBlur'), uSharpen:U('uSharpen'), uGlow:U('uGlow'), uGlowT:U('uGlowT'),
        uBlendMode:U('uBlendMode'), uHiBoost:U('uHiBoost'), uHiThresh:U('uHiThresh')
      };
      return { gl, prog, tex, uniforms };
    };
  }
  const makeGL = window.EnvMirror.makeGL;

  /* Engine */
  if (!window.EnvButtons) {
    window.EnvButtons = (function(){
      const instances = new Map();
      function hfovToVfov(hfov, aspect){ return 2*Math.atan(Math.tan(hfov/2)/aspect); }
      function shapeCode(name){
        if(name==='pill') return 2.0;
        if(name==='squircle') return 4.0;
        if(name==='concave') return 5.0;
        if(name==='flat') return 6.0;
        if(name==='roundrect') return 7.0;   // NEW
        return 0.0;
      }
      function blendCode(s){ return s==='screen'?1.0 : s==='overlay'?2.0 : s==='soft'?3.0 : 0.0; }
      function parseHex(hex, fallback){
        const m = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex||"");
        if(!m) return fallback||[0.82,0.84,0.87];
        return [ parseInt(m[1],16)/255, parseInt(m[2],16)/255, parseInt(m[3],16)/255 ];
      }

      function create(host, opts){
        const options = Object.assign({
          hfovDeg:100, projection:'rect', flip:true,
          ripple:0.10, roundHint:0.75,
          base:[0.82,0.84,0.87], envMix:0.48, exposure:1.35, saturation:1.0,
          blur:1.0, sharpen:0.50, glow:0.40, glowT:0.62,
          edgeAmp:0.30, edgeWidth:0.08,
          camZoom:1.18, uvMargin:0.04,
          corner:0.22, hiBoost:0.40, hiThresh:0.62,
          blend:'screen'
        }, opts||{});
        const dataBase = host.getAttribute('data-base'); if (dataBase) options.base = parseHex(dataBase, options.base);
        const dataCorner = host.getAttribute('data-corner'); if (dataCorner) options.corner = Math.max(0, Math.min(0.45, parseFloat(dataCorner)));

        let canvas = host.querySelector('canvas'); if(!canvas){ canvas = document.createElement('canvas'); host.appendChild(canvas); }
        const glx = makeGL(canvas); const gl = glx.gl;

        const dpr = Math.max(1, window.devicePixelRatio||1);
        function resize(){
          const r = host.getBoundingClientRect();
          const W = Math.max(1,(r.width*dpr)|0), H = Math.max(1,(r.height*dpr)|0);
          if(canvas.width!==W||canvas.height!==H){ canvas.width=W; canvas.height=H; gl.viewport(0,0,W,H); }
        }
        const ro = new ResizeObserver(resize); ro.observe(host); resize();

        const t0 = performance.now();
        const shapeName = host.getAttribute('data-shape') || 'roundrect';

        function frame(now){
          const v = Camera.state.video; if(!v){ requestAnimationFrame(frame); return; }
          gl.clear(gl.COLOR_BUFFER_BIT);
          gl.activeTexture(gl.TEXTURE0); gl.bindTexture(gl.TEXTURE_2D, glx.tex);
          try{ gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,v); }catch(e){}

          const r = host.getBoundingClientRect();
          gl.uniform2f(glx.uniforms.uRes, r.width, r.height);
          gl.uniform1i(glx.uniforms.uCam, 0);
          gl.uniform2f(glx.uniforms.uCamSize, v.videoWidth||640, v.videoHeight||480);

          const hf = options.hfovDeg*Math.PI/180;
          const vf = hfovToVfov(hf, (v.videoWidth||16)/(v.videoHeight||9));
          gl.uniform1f(glx.uniforms.uHFov, hf);
          gl.uniform1f(glx.uniforms.uVFov, vf);
          gl.uniform1f(glx.uniforms.uFlip, options.flip?1.0:0.0);

          gl.uniform1f(glx.uniforms.uProjection, options.projection==='rect'? 0.0 : 1.0);
          gl.uniform1f(glx.uniforms.uCamZoom, options.camZoom);
          gl.uniform1f(glx.uniforms.uUVMargin, options.uvMargin);

          gl.uniform1f(glx.uniforms.uRipple, options.ripple);
          gl.uniform1f(glx.uniforms.uRound, options.roundHint);
          gl.uniform1f(glx.uniforms.uShape, shapeCode(shapeName));
          gl.uniform1f(glx.uniforms.uCorner, options.corner);
          gl.uniform1f(glx.uniforms.uEdgeAmp, options.edgeAmp);
          gl.uniform1f(glx.uniforms.uEdgeWidth, options.edgeWidth);

          gl.uniform3f(glx.uniforms.uBaseColor, options.base[0], options.base[1], options.base[2]);
          gl.uniform1f(glx.uniforms.uEnvMix, options.envMix);
          gl.uniform1f(glx.uniforms.uExposure, options.exposure);
          gl.uniform1f(glx.uniforms.uSaturation, options.saturation);
          gl.uniform1f(glx.uniforms.uBlur, options.blur);
          gl.uniform1f(glx.uniforms.uSharpen, options.sharpen);
          gl.uniform1f(glx.uniforms.uGlow, options.glow);
          gl.uniform1f(glx.uniforms.uGlowT, options.glowT);
          gl.uniform1f(glx.uniforms.uBlendMode, (options.blend==='screen'?1.0:options.blend==='overlay'?2.0:options.blend==='soft'?3.0:0.0));
          gl.uniform1f(glx.uniforms.uHiBoost, options.hiBoost);
          gl.uniform1f(glx.uniforms.uHiThresh, options.hiThresh);

          gl.uniform1f(glx.uniforms.uTime, (now - t0)/1000);
          gl.drawArrays(gl.TRIANGLES, 0, 6);
          requestAnimationFrame(frame);
        }
        requestAnimationFrame(frame);

        instances.set(host, { host, canvas, glx, options });
        return instances.get(host);
      }

      async function applyTo(selector, options){
        await Camera.ensure();
        document.querySelectorAll(selector||'.env-ui').forEach(el=>{
          if(!el.__envBtn) el.__envBtn = create(el, options);
        });
      }
      function setAllOptions(patch){ instances.forEach(inst => Object.assign(inst.options, patch||{})); }
      return { applyTo, instances, setAllOptions };
    })();
  }

  /* UI */
  document.addEventListener('DOMContentLoaded', async function(){
    await window.EnvButtons.applyTo('.env-ui', {});

    function $(id){ return document.getElementById(id); }
    const bind = (el, chip, key, fmt=(v)=>v.toFixed(2))=>{
      el.addEventListener('input', ()=>{ const v= (el.type==='range')? +el.value : el.value; chip.textContent = (typeof v==='number')? fmt(v) : v; const patch={}; patch[key]=v; EnvButtons.setAllOptions(patch); });
    };

    bind($('hfov'), $('hfovVal'), 'hfovDeg', v=>v+'°');
    bind($('corner'), $('cornerVal'), 'corner');
    bind($('edgeW'), $('edgeWVal'), 'edgeWidth');
    bind($('edgeAmp'), $('edgeAmpVal'), 'edgeAmp');
    bind($('envMix'), $('envMixVal'), 'envMix');
    bind($('exposure'), $('expVal'), 'exposure');
    bind($('sharpen'), $('sharpVal'), 'sharpen');
    bind($('glow'), $('glowVal'), 'glow');
    bind($('camZoom'), $('zoomVal'), 'camZoom', v=>v.toFixed(2)+'×');
    bind($('hiboost'), $('hiboostVal'), 'hiBoost');
    bind($('hithresh'), $('hithreshVal'), 'hiThresh');

    $('blend').addEventListener('change', ()=> EnvButtons.setAllOptions({ blend: $('blend').value }));
    $('projection').addEventListener('change', ()=> EnvButtons.setAllOptions({ projection: $('projection').value==='equirect'?'equirect':'rect' }));
    $('flip').addEventListener('click', ()=> EnvButtons.instances.forEach(inst => inst.options.flip = !inst.options.flip));
  });
})();
</script>
</body>
</html>
